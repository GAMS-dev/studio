/**
 * GAMS Engine
 * With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.
 *
 * The version of the OpenAPI document: 23.06.02
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAuthApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIAuthApi::OAIAuthApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIAuthApi::~OAIAuthApi() {
}

void OAIAuthApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//localhost/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("createJWTToken", defaultConf);
    _serverIndices.insert("createJWTToken", 0);
    _serverConfigs.insert("createJWTTokenJSON", defaultConf);
    _serverIndices.insert("createJWTTokenJSON", 0);
    _serverConfigs.insert("createLDAPIdentityProvider", defaultConf);
    _serverIndices.insert("createLDAPIdentityProvider", 0);
    _serverConfigs.insert("createOAuth2IdentityProvider", defaultConf);
    _serverIndices.insert("createOAuth2IdentityProvider", 0);
    _serverConfigs.insert("createOIDCIdentityProvider", defaultConf);
    _serverIndices.insert("createOIDCIdentityProvider", 0);
    _serverConfigs.insert("deleteIdentityProvider", defaultConf);
    _serverIndices.insert("deleteIdentityProvider", 0);
    _serverConfigs.insert("fetchOAuth2TokenOnBehalf", defaultConf);
    _serverIndices.insert("fetchOAuth2TokenOnBehalf", 0);
    _serverConfigs.insert("invalidateJWTTokens", defaultConf);
    _serverIndices.insert("invalidateJWTTokens", 0);
    _serverConfigs.insert("listAllIdentityProviders", defaultConf);
    _serverIndices.insert("listAllIdentityProviders", 0);
    _serverConfigs.insert("listIdentityProviders", defaultConf);
    _serverIndices.insert("listIdentityProviders", 0);
    _serverConfigs.insert("listLDAPIdentityProviders", defaultConf);
    _serverIndices.insert("listLDAPIdentityProviders", 0);
    _serverConfigs.insert("listOAuth2IdentityProviders", defaultConf);
    _serverIndices.insert("listOAuth2IdentityProviders", 0);
    _serverConfigs.insert("listOIDCIdentityProviders", defaultConf);
    _serverIndices.insert("listOIDCIdentityProviders", 0);
    _serverConfigs.insert("loginWithLDAP", defaultConf);
    _serverIndices.insert("loginWithLDAP", 0);
    _serverConfigs.insert("loginWithOIDC", defaultConf);
    _serverIndices.insert("loginWithOIDC", 0);
    _serverConfigs.insert("updateLDAPIdentityProvider", defaultConf);
    _serverIndices.insert("updateLDAPIdentityProvider", 0);
    _serverConfigs.insert("updateOAuth2IdentityProvider", defaultConf);
    _serverIndices.insert("updateOAuth2IdentityProvider", 0);
    _serverConfigs.insert("updateOIDCIdentityProvider", defaultConf);
    _serverIndices.insert("updateOIDCIdentityProvider", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIAuthApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIAuthApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIAuthApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName,apiKey);
}

void OAIAuthApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIAuthApi::setUsername(const QString &username) {
    _username = username;
}

void OAIAuthApi::setPassword(const QString &password) {
    _password = password;
}


void OAIAuthApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIAuthApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIAuthApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIAuthApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAuthApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 12, 0)
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
#else
    for (auto &e : _serverIndices.keys()) {
        setServerIndex(e, addServerConfiguration(e, url, description, variables));
    }
#endif
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAuthApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIAuthApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIAuthApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIAuthApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIAuthApi::abortRequests() {
    emit abortRequestsSignal();
}

QString OAIAuthApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIAuthApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIAuthApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIAuthApi::createJWTToken(const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QString> &scope) {
    QString fullPath = QString(_serverConfigs["createJWTToken"][_serverIndices.value("createJWTToken")].URL()+"/auth/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createJWTTokenCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createJWTTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createJWTTokenSignal(output);
        emit createJWTTokenSignalFull(worker, output);
    } else {
        emit createJWTTokenSignalE(output, error_type, error_str);
        emit createJWTTokenSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createJWTTokenJSON(const QString &username, const QString &password, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QList<QString>> &access_scopes) {
    QString fullPath = QString(_serverConfigs["createJWTTokenJSON"][_serverIndices.value("createJWTTokenJSON")].URL()+"/auth/login");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (grant_type.hasValue())
    {
        input.add_var("grant_type", ::OpenAPI::toStringValue(grant_type.value()));
    }
    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }
    
    {
        input.add_var("password", ::OpenAPI::toStringValue(password));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (access_scopes.hasValue())
    {
        input.add_var("access_scopes", ::OpenAPI::toStringValue(access_scopes.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createJWTTokenJSONCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createJWTTokenJSONCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createJWTTokenJSONSignal(output);
        emit createJWTTokenJSONSignalFull(worker, output);
    } else {
        emit createJWTTokenJSONSignalE(output, error_type, error_str);
        emit createJWTTokenJSONSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createLDAPIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &host, const qint32 &port, const QString &uid, const QString &encryption, const QString &base, const QString &user_filter, const ::OpenAPI::OptionalParam<QString> &bind_dn, const ::OpenAPI::OptionalParam<QString> &password, const ::OpenAPI::OptionalParam<bool> &verify_certificates, const ::OpenAPI::OptionalParam<bool> &active_directory) {
    QString fullPath = QString(_serverConfigs["createLDAPIdentityProvider"][_serverIndices.value("createLDAPIdentityProvider")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("host", ::OpenAPI::toStringValue(host));
    }
    
    {
        input.add_var("port", ::OpenAPI::toStringValue(port));
    }
    
    {
        input.add_var("uid", ::OpenAPI::toStringValue(uid));
    }
    if (bind_dn.hasValue())
    {
        input.add_var("bind_dn", ::OpenAPI::toStringValue(bind_dn.value()));
    }
    if (password.hasValue())
    {
        input.add_var("password", ::OpenAPI::toStringValue(password.value()));
    }
    
    {
        input.add_var("encryption", ::OpenAPI::toStringValue(encryption));
    }
    if (verify_certificates.hasValue())
    {
        input.add_var("verify_certificates", ::OpenAPI::toStringValue(verify_certificates.value()));
    }
    if (active_directory.hasValue())
    {
        input.add_var("active_directory", ::OpenAPI::toStringValue(active_directory.value()));
    }
    
    {
        input.add_var("base", ::OpenAPI::toStringValue(base));
    }
    
    {
        input.add_var("user_filter", ::OpenAPI::toStringValue(user_filter));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createLDAPIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createLDAPIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createLDAPIdentityProviderSignal(output);
        emit createLDAPIdentityProviderSignalFull(worker, output);
    } else {
        emit createLDAPIdentityProviderSignalE(output, error_type, error_str);
        emit createLDAPIdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createOAuth2IdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &override_audience, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<bool> &use_oauth2_auth_server_metadata, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QList<QString>> &response_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &grant_types_supported, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &request_scope_readonly, const ::OpenAPI::OptionalParam<QString> &request_scope_namespaces, const ::OpenAPI::OptionalParam<QString> &request_scope_jobs, const ::OpenAPI::OptionalParam<QString> &request_scope_users, const ::OpenAPI::OptionalParam<QString> &request_scope_hypercube, const ::OpenAPI::OptionalParam<QString> &request_scope_cleanup, const ::OpenAPI::OptionalParam<QString> &request_scope_licenses, const ::OpenAPI::OptionalParam<QString> &request_scope_usage, const ::OpenAPI::OptionalParam<QString> &request_scope_auth, const ::OpenAPI::OptionalParam<QString> &request_scope_configuration) {
    QString fullPath = QString(_serverConfigs["createOAuth2IdentityProvider"][_serverIndices.value("createOAuth2IdentityProvider")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (override_audience.hasValue())
    {
        input.add_var("override_audience", ::OpenAPI::toStringValue(override_audience.value()));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (use_oauth2_auth_server_metadata.hasValue())
    {
        input.add_var("use_oauth2_auth_server_metadata", ::OpenAPI::toStringValue(use_oauth2_auth_server_metadata.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (response_types_supported.hasValue())
    {
        input.add_var("response_types_supported", ::OpenAPI::toStringValue(response_types_supported.value()));
    }
    if (grant_types_supported.hasValue())
    {
        input.add_var("grant_types_supported", ::OpenAPI::toStringValue(grant_types_supported.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (request_scope_readonly.hasValue())
    {
        input.add_var("request_scope_READONLY", ::OpenAPI::toStringValue(request_scope_readonly.value()));
    }
    if (request_scope_namespaces.hasValue())
    {
        input.add_var("request_scope_NAMESPACES", ::OpenAPI::toStringValue(request_scope_namespaces.value()));
    }
    if (request_scope_jobs.hasValue())
    {
        input.add_var("request_scope_JOBS", ::OpenAPI::toStringValue(request_scope_jobs.value()));
    }
    if (request_scope_users.hasValue())
    {
        input.add_var("request_scope_USERS", ::OpenAPI::toStringValue(request_scope_users.value()));
    }
    if (request_scope_hypercube.hasValue())
    {
        input.add_var("request_scope_HYPERCUBE", ::OpenAPI::toStringValue(request_scope_hypercube.value()));
    }
    if (request_scope_cleanup.hasValue())
    {
        input.add_var("request_scope_CLEANUP", ::OpenAPI::toStringValue(request_scope_cleanup.value()));
    }
    if (request_scope_licenses.hasValue())
    {
        input.add_var("request_scope_LICENSES", ::OpenAPI::toStringValue(request_scope_licenses.value()));
    }
    if (request_scope_usage.hasValue())
    {
        input.add_var("request_scope_USAGE", ::OpenAPI::toStringValue(request_scope_usage.value()));
    }
    if (request_scope_auth.hasValue())
    {
        input.add_var("request_scope_AUTH", ::OpenAPI::toStringValue(request_scope_auth.value()));
    }
    if (request_scope_configuration.hasValue())
    {
        input.add_var("request_scope_CONFIGURATION", ::OpenAPI::toStringValue(request_scope_configuration.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createOAuth2IdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createOAuth2IdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createOAuth2IdentityProviderSignal(output);
        emit createOAuth2IdentityProviderSignalFull(worker, output);
    } else {
        emit createOAuth2IdentityProviderSignalE(output, error_type, error_str);
        emit createOAuth2IdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createOIDCIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const QList<QString> &scopes, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &device_client_secret, const ::OpenAPI::OptionalParam<QList<QString>> &extra_client_ids, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint) {
    QString fullPath = QString(_serverConfigs["createOIDCIdentityProvider"][_serverIndices.value("createOIDCIdentityProvider")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    if (device_client_secret.hasValue())
    {
        input.add_var("device_client_secret", ::OpenAPI::toStringValue(device_client_secret.value()));
    }
    if (extra_client_ids.hasValue())
    {
        input.add_var("extra_client_ids", ::OpenAPI::toStringValue(extra_client_ids.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    
    {
        input.add_var("scopes", ::OpenAPI::toStringValue(scopes));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createOIDCIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createOIDCIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createOIDCIdentityProviderSignal(output);
        emit createOIDCIdentityProviderSignalFull(worker, output);
    } else {
        emit createOIDCIdentityProviderSignalE(output, error_type, error_str);
        emit createOIDCIdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::deleteIdentityProvider(const QString &name) {
    QString fullPath = QString(_serverConfigs["deleteIdentityProvider"][_serverIndices.value("deleteIdentityProvider")].URL()+"/auth/providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::deleteIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::deleteIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteIdentityProviderSignal(output);
        emit deleteIdentityProviderSignalFull(worker, output);
    } else {
        emit deleteIdentityProviderSignalE(output, error_type, error_str);
        emit deleteIdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::fetchOAuth2TokenOnBehalf(const QString &identity_provider_name, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &code, const ::OpenAPI::OptionalParam<QString> &code_verifier, const ::OpenAPI::OptionalParam<QString> &redirect_uri, const ::OpenAPI::OptionalParam<QString> &device_code) {
    QString fullPath = QString(_serverConfigs["fetchOAuth2TokenOnBehalf"][_serverIndices.value("fetchOAuth2TokenOnBehalf")].URL()+"/auth/oauth2-token");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (grant_type.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "grant_type", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("grant_type")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(grant_type.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("identity_provider_name", ::OpenAPI::toStringValue(identity_provider_name));
    }
    if (code.hasValue())
    {
        input.add_var("code", ::OpenAPI::toStringValue(code.value()));
    }
    if (code_verifier.hasValue())
    {
        input.add_var("code_verifier", ::OpenAPI::toStringValue(code_verifier.value()));
    }
    if (redirect_uri.hasValue())
    {
        input.add_var("redirect_uri", ::OpenAPI::toStringValue(redirect_uri.value()));
    }
    if (device_code.hasValue())
    {
        input.add_var("device_code", ::OpenAPI::toStringValue(device_code.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::fetchOAuth2TokenOnBehalfCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::fetchOAuth2TokenOnBehalfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIForwarded_token_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit fetchOAuth2TokenOnBehalfSignal(output);
        emit fetchOAuth2TokenOnBehalfSignalFull(worker, output);
    } else {
        emit fetchOAuth2TokenOnBehalfSignalE(output, error_type, error_str);
        emit fetchOAuth2TokenOnBehalfSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::invalidateJWTTokens() {
    QString fullPath = QString(_serverConfigs["invalidateJWTTokens"][_serverIndices.value("invalidateJWTTokens")].URL()+"/auth/logout");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::invalidateJWTTokensCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::invalidateJWTTokensCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit invalidateJWTTokensSignal(output);
        emit invalidateJWTTokensSignalFull(worker, output);
    } else {
        emit invalidateJWTTokensSignalE(output, error_type, error_str);
        emit invalidateJWTTokensSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listAllIdentityProviders() {
    QString fullPath = QString(_serverConfigs["listAllIdentityProviders"][_serverIndices.value("listAllIdentityProviders")].URL()+"/auth/providers/all");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listAllIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listAllIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIIdentity_provider val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listAllIdentityProvidersSignal(output);
        emit listAllIdentityProvidersSignalFull(worker, output);
    } else {
        emit listAllIdentityProvidersSignalE(output, error_type, error_str);
        emit listAllIdentityProvidersSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name) {
    QString fullPath = QString(_serverConfigs["listIdentityProviders"][_serverIndices.value("listIdentityProviders")].URL()+"/auth/providers");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIIdentity_provider val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listIdentityProvidersSignal(output);
        emit listIdentityProvidersSignalFull(worker, output);
    } else {
        emit listIdentityProvidersSignalE(output, error_type, error_str);
        emit listIdentityProvidersSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listLDAPIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listLDAPIdentityProviders"][_serverIndices.value("listLDAPIdentityProviders")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listLDAPIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listLDAPIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentity_provider_ldap output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listLDAPIdentityProvidersSignal(output);
        emit listLDAPIdentityProvidersSignalFull(worker, output);
    } else {
        emit listLDAPIdentityProvidersSignalE(output, error_type, error_str);
        emit listLDAPIdentityProvidersSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listOAuth2IdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listOAuth2IdentityProviders"][_serverIndices.value("listOAuth2IdentityProviders")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listOAuth2IdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listOAuth2IdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider_oauth2_with_secret> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIIdentity_provider_oauth2_with_secret val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listOAuth2IdentityProvidersSignal(output);
        emit listOAuth2IdentityProvidersSignalFull(worker, output);
    } else {
        emit listOAuth2IdentityProvidersSignalE(output, error_type, error_str);
        emit listOAuth2IdentityProvidersSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listOIDCIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listOIDCIdentityProviders"][_serverIndices.value("listOIDCIdentityProviders")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listOIDCIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listOIDCIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider_oidc_with_secret> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIIdentity_provider_oidc_with_secret val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listOIDCIdentityProvidersSignal(output);
        emit listOIDCIdentityProvidersSignalFull(worker, output);
    } else {
        emit listOIDCIdentityProvidersSignalE(output, error_type, error_str);
        emit listOIDCIdentityProvidersSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::loginWithLDAP(const QString &provider_name, const QString &username, const QString &password, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QList<QString>> &access_scopes) {
    QString fullPath = QString(_serverConfigs["loginWithLDAP"][_serverIndices.value("loginWithLDAP")].URL()+"/auth/ldap-providers/{provider_name}/login");
    
    
    {
        QString provider_namePathParam("{");
        provider_namePathParam.append("provider_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider_name"+pathSuffix : pathPrefix;
        fullPath.replace(provider_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (grant_type.hasValue())
    {
        input.add_var("grant_type", ::OpenAPI::toStringValue(grant_type.value()));
    }
    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }
    
    {
        input.add_var("password", ::OpenAPI::toStringValue(password));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (access_scopes.hasValue())
    {
        input.add_var("access_scopes", ::OpenAPI::toStringValue(access_scopes.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::loginWithLDAPCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::loginWithLDAPCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit loginWithLDAPSignal(output);
        emit loginWithLDAPSignalFull(worker, output);
    } else {
        emit loginWithLDAPSignalE(output, error_type, error_str);
        emit loginWithLDAPSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::loginWithOIDC(const QString &id_token, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in) {
    QString fullPath = QString(_serverConfigs["loginWithOIDC"][_serverIndices.value("loginWithOIDC")].URL()+"/auth/oidc-providers/login");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("id_token", ::OpenAPI::toStringValue(id_token));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::loginWithOIDCCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::loginWithOIDCCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit loginWithOIDCSignal(output);
        emit loginWithOIDCSignalFull(worker, output);
    } else {
        emit loginWithOIDCSignalE(output, error_type, error_str);
        emit loginWithOIDCSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateLDAPIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &host, const qint32 &port, const QString &uid, const QString &encryption, const QString &base, const QString &user_filter, const ::OpenAPI::OptionalParam<QString> &bind_dn, const ::OpenAPI::OptionalParam<QString> &password, const ::OpenAPI::OptionalParam<bool> &verify_certificates, const ::OpenAPI::OptionalParam<bool> &active_directory) {
    QString fullPath = QString(_serverConfigs["updateLDAPIdentityProvider"][_serverIndices.value("updateLDAPIdentityProvider")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("host", ::OpenAPI::toStringValue(host));
    }
    
    {
        input.add_var("port", ::OpenAPI::toStringValue(port));
    }
    
    {
        input.add_var("uid", ::OpenAPI::toStringValue(uid));
    }
    if (bind_dn.hasValue())
    {
        input.add_var("bind_dn", ::OpenAPI::toStringValue(bind_dn.value()));
    }
    if (password.hasValue())
    {
        input.add_var("password", ::OpenAPI::toStringValue(password.value()));
    }
    
    {
        input.add_var("encryption", ::OpenAPI::toStringValue(encryption));
    }
    if (verify_certificates.hasValue())
    {
        input.add_var("verify_certificates", ::OpenAPI::toStringValue(verify_certificates.value()));
    }
    if (active_directory.hasValue())
    {
        input.add_var("active_directory", ::OpenAPI::toStringValue(active_directory.value()));
    }
    
    {
        input.add_var("base", ::OpenAPI::toStringValue(base));
    }
    
    {
        input.add_var("user_filter", ::OpenAPI::toStringValue(user_filter));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateLDAPIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateLDAPIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateLDAPIdentityProviderSignal(output);
        emit updateLDAPIdentityProviderSignalFull(worker, output);
    } else {
        emit updateLDAPIdentityProviderSignalE(output, error_type, error_str);
        emit updateLDAPIdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateOAuth2IdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &override_audience, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<bool> &use_oauth2_auth_server_metadata, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QList<QString>> &response_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &grant_types_supported, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &request_scope_readonly, const ::OpenAPI::OptionalParam<QString> &request_scope_namespaces, const ::OpenAPI::OptionalParam<QString> &request_scope_jobs, const ::OpenAPI::OptionalParam<QString> &request_scope_users, const ::OpenAPI::OptionalParam<QString> &request_scope_hypercube, const ::OpenAPI::OptionalParam<QString> &request_scope_cleanup, const ::OpenAPI::OptionalParam<QString> &request_scope_licenses, const ::OpenAPI::OptionalParam<QString> &request_scope_usage, const ::OpenAPI::OptionalParam<QString> &request_scope_auth, const ::OpenAPI::OptionalParam<QString> &request_scope_configuration) {
    QString fullPath = QString(_serverConfigs["updateOAuth2IdentityProvider"][_serverIndices.value("updateOAuth2IdentityProvider")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (override_audience.hasValue())
    {
        input.add_var("override_audience", ::OpenAPI::toStringValue(override_audience.value()));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (use_oauth2_auth_server_metadata.hasValue())
    {
        input.add_var("use_oauth2_auth_server_metadata", ::OpenAPI::toStringValue(use_oauth2_auth_server_metadata.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (response_types_supported.hasValue())
    {
        input.add_var("response_types_supported", ::OpenAPI::toStringValue(response_types_supported.value()));
    }
    if (grant_types_supported.hasValue())
    {
        input.add_var("grant_types_supported", ::OpenAPI::toStringValue(grant_types_supported.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (request_scope_readonly.hasValue())
    {
        input.add_var("request_scope_READONLY", ::OpenAPI::toStringValue(request_scope_readonly.value()));
    }
    if (request_scope_namespaces.hasValue())
    {
        input.add_var("request_scope_NAMESPACES", ::OpenAPI::toStringValue(request_scope_namespaces.value()));
    }
    if (request_scope_jobs.hasValue())
    {
        input.add_var("request_scope_JOBS", ::OpenAPI::toStringValue(request_scope_jobs.value()));
    }
    if (request_scope_users.hasValue())
    {
        input.add_var("request_scope_USERS", ::OpenAPI::toStringValue(request_scope_users.value()));
    }
    if (request_scope_hypercube.hasValue())
    {
        input.add_var("request_scope_HYPERCUBE", ::OpenAPI::toStringValue(request_scope_hypercube.value()));
    }
    if (request_scope_cleanup.hasValue())
    {
        input.add_var("request_scope_CLEANUP", ::OpenAPI::toStringValue(request_scope_cleanup.value()));
    }
    if (request_scope_licenses.hasValue())
    {
        input.add_var("request_scope_LICENSES", ::OpenAPI::toStringValue(request_scope_licenses.value()));
    }
    if (request_scope_usage.hasValue())
    {
        input.add_var("request_scope_USAGE", ::OpenAPI::toStringValue(request_scope_usage.value()));
    }
    if (request_scope_auth.hasValue())
    {
        input.add_var("request_scope_AUTH", ::OpenAPI::toStringValue(request_scope_auth.value()));
    }
    if (request_scope_configuration.hasValue())
    {
        input.add_var("request_scope_CONFIGURATION", ::OpenAPI::toStringValue(request_scope_configuration.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateOAuth2IdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateOAuth2IdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateOAuth2IdentityProviderSignal(output);
        emit updateOAuth2IdentityProviderSignalFull(worker, output);
    } else {
        emit updateOAuth2IdentityProviderSignalE(output, error_type, error_str);
        emit updateOAuth2IdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateOIDCIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const QList<QString> &scopes, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &device_client_secret, const ::OpenAPI::OptionalParam<QList<QString>> &extra_client_ids, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint) {
    QString fullPath = QString(_serverConfigs["updateOIDCIdentityProvider"][_serverIndices.value("updateOIDCIdentityProvider")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    if (device_client_secret.hasValue())
    {
        input.add_var("device_client_secret", ::OpenAPI::toStringValue(device_client_secret.value()));
    }
    if (extra_client_ids.hasValue())
    {
        input.add_var("extra_client_ids", ::OpenAPI::toStringValue(extra_client_ids.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    
    {
        input.add_var("scopes", ::OpenAPI::toStringValue(scopes));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateOIDCIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateOIDCIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateOIDCIdentityProviderSignal(output);
        emit updateOIDCIdentityProviderSignalFull(worker, output);
    } else {
        emit updateOIDCIdentityProviderSignalE(output, error_type, error_str);
        emit updateOIDCIdentityProviderSignalEFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::tokenAvailable(){
  
    oauthToken token; 
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
