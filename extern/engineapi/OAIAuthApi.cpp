/**
 * GAMS Engine
 * With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.
 *
 * The version of the OpenAPI document: 25.04.23
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAuthApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIAuthApi::OAIAuthApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIAuthApi::~OAIAuthApi() {
}

void OAIAuthApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//localhost/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("createJWTToken", defaultConf);
    _serverIndices.insert("createJWTToken", 0);
    _serverConfigs.insert("createJWTTokenJSON", defaultConf);
    _serverIndices.insert("createJWTTokenJSON", 0);
    _serverConfigs.insert("createLDAPIdentityProvider", defaultConf);
    _serverIndices.insert("createLDAPIdentityProvider", 0);
    _serverConfigs.insert("createOAuth2IdentityProvider", defaultConf);
    _serverIndices.insert("createOAuth2IdentityProvider", 0);
    _serverConfigs.insert("createOIDCIdentityProvider", defaultConf);
    _serverIndices.insert("createOIDCIdentityProvider", 0);
    _serverConfigs.insert("deleteIdentityProvider", defaultConf);
    _serverIndices.insert("deleteIdentityProvider", 0);
    _serverConfigs.insert("fetchOAuth2TokenOnBehalf", defaultConf);
    _serverIndices.insert("fetchOAuth2TokenOnBehalf", 0);
    _serverConfigs.insert("getPasswordPolicy", defaultConf);
    _serverIndices.insert("getPasswordPolicy", 0);
    _serverConfigs.insert("invalidateJWTTokens", defaultConf);
    _serverIndices.insert("invalidateJWTTokens", 0);
    _serverConfigs.insert("listAllIdentityProviders", defaultConf);
    _serverIndices.insert("listAllIdentityProviders", 0);
    _serverConfigs.insert("listIdentityProviders", defaultConf);
    _serverIndices.insert("listIdentityProviders", 0);
    _serverConfigs.insert("listLDAPIdentityProviders", defaultConf);
    _serverIndices.insert("listLDAPIdentityProviders", 0);
    _serverConfigs.insert("listOAuth2IdentityProviders", defaultConf);
    _serverIndices.insert("listOAuth2IdentityProviders", 0);
    _serverConfigs.insert("listOIDCIdentityProviders", defaultConf);
    _serverIndices.insert("listOIDCIdentityProviders", 0);
    _serverConfigs.insert("loginWithLDAP", defaultConf);
    _serverIndices.insert("loginWithLDAP", 0);
    _serverConfigs.insert("loginWithOIDC", defaultConf);
    _serverIndices.insert("loginWithOIDC", 0);
    _serverConfigs.insert("updateLDAPIdentityProvider", defaultConf);
    _serverIndices.insert("updateLDAPIdentityProvider", 0);
    _serverConfigs.insert("updateOAuth2IdentityProvider", defaultConf);
    _serverIndices.insert("updateOAuth2IdentityProvider", 0);
    _serverConfigs.insert("updateOIDCIdentityProvider", defaultConf);
    _serverIndices.insert("updateOIDCIdentityProvider", 0);
    _serverConfigs.insert("updatePasswordPolicy", defaultConf);
    _serverIndices.insert("updatePasswordPolicy", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIAuthApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIAuthApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIAuthApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIAuthApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIAuthApi::setUsername(const QString &username) {
    _username = username;
}

void OAIAuthApi::setPassword(const QString &password) {
    _password = password;
}


void OAIAuthApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIAuthApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIAuthApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIAuthApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAuthApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAuthApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIAuthApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIAuthApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIAuthApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIAuthApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIAuthApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIAuthApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIAuthApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIAuthApi::createJWTToken(const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QString> &scope) {
    QString fullPath = QString(_serverConfigs["createJWTToken"][_serverIndices.value("createJWTToken")].URL()+"/auth/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createJWTTokenCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createJWTTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createJWTTokenSignal(output);
        Q_EMIT createJWTTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createJWTTokenSignalE(output, error_type, error_str);
        Q_EMIT createJWTTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createJWTTokenSignalError(output, error_type, error_str);
        Q_EMIT createJWTTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createJWTTokenJSON(const QString &username, const QString &password, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QList<QString>> &access_scopes) {
    QString fullPath = QString(_serverConfigs["createJWTTokenJSON"][_serverIndices.value("createJWTTokenJSON")].URL()+"/auth/login");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (grant_type.hasValue())
    {
        input.add_var("grant_type", ::OpenAPI::toStringValue(grant_type.value()));
    }
    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }
    
    {
        input.add_var("password", ::OpenAPI::toStringValue(password));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (access_scopes.hasValue())
    {
        input.add_var("access_scopes", ::OpenAPI::toStringValue(access_scopes.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createJWTTokenJSONCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createJWTTokenJSONCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createJWTTokenJSONSignal(output);
        Q_EMIT createJWTTokenJSONSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createJWTTokenJSONSignalE(output, error_type, error_str);
        Q_EMIT createJWTTokenJSONSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createJWTTokenJSONSignalError(output, error_type, error_str);
        Q_EMIT createJWTTokenJSONSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createLDAPIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &host, const qint32 &port, const QString &uid, const QString &encryption, const QString &base, const QString &user_filter, const ::OpenAPI::OptionalParam<QString> &bind_dn, const ::OpenAPI::OptionalParam<QString> &password, const ::OpenAPI::OptionalParam<bool> &verify_certificates, const ::OpenAPI::OptionalParam<bool> &active_directory) {
    QString fullPath = QString(_serverConfigs["createLDAPIdentityProvider"][_serverIndices.value("createLDAPIdentityProvider")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("host", ::OpenAPI::toStringValue(host));
    }
    
    {
        input.add_var("port", ::OpenAPI::toStringValue(port));
    }
    
    {
        input.add_var("uid", ::OpenAPI::toStringValue(uid));
    }
    if (bind_dn.hasValue())
    {
        input.add_var("bind_dn", ::OpenAPI::toStringValue(bind_dn.value()));
    }
    if (password.hasValue())
    {
        input.add_var("password", ::OpenAPI::toStringValue(password.value()));
    }
    
    {
        input.add_var("encryption", ::OpenAPI::toStringValue(encryption));
    }
    if (verify_certificates.hasValue())
    {
        input.add_var("verify_certificates", ::OpenAPI::toStringValue(verify_certificates.value()));
    }
    if (active_directory.hasValue())
    {
        input.add_var("active_directory", ::OpenAPI::toStringValue(active_directory.value()));
    }
    
    {
        input.add_var("base", ::OpenAPI::toStringValue(base));
    }
    
    {
        input.add_var("user_filter", ::OpenAPI::toStringValue(user_filter));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createLDAPIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createLDAPIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createLDAPIdentityProviderSignal(output);
        Q_EMIT createLDAPIdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createLDAPIdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT createLDAPIdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createLDAPIdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT createLDAPIdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createOAuth2IdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &override_audience, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<bool> &use_oauth2_auth_server_metadata, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QList<QString>> &response_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &grant_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &token_endpoint_auth_methods_supported, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &request_scope_readonly, const ::OpenAPI::OptionalParam<QString> &request_scope_namespaces, const ::OpenAPI::OptionalParam<QString> &request_scope_jobs, const ::OpenAPI::OptionalParam<QString> &request_scope_users, const ::OpenAPI::OptionalParam<QString> &request_scope_hypercube, const ::OpenAPI::OptionalParam<QString> &request_scope_cleanup, const ::OpenAPI::OptionalParam<QString> &request_scope_licenses, const ::OpenAPI::OptionalParam<QString> &request_scope_usage, const ::OpenAPI::OptionalParam<QString> &request_scope_auth, const ::OpenAPI::OptionalParam<QString> &request_scope_configuration) {
    QString fullPath = QString(_serverConfigs["createOAuth2IdentityProvider"][_serverIndices.value("createOAuth2IdentityProvider")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (override_audience.hasValue())
    {
        input.add_var("override_audience", ::OpenAPI::toStringValue(override_audience.value()));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (use_oauth2_auth_server_metadata.hasValue())
    {
        input.add_var("use_oauth2_auth_server_metadata", ::OpenAPI::toStringValue(use_oauth2_auth_server_metadata.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (response_types_supported.hasValue())
    {
        input.add_var("response_types_supported", ::OpenAPI::toStringValue(response_types_supported.value()));
    }
    if (grant_types_supported.hasValue())
    {
        input.add_var("grant_types_supported", ::OpenAPI::toStringValue(grant_types_supported.value()));
    }
    if (token_endpoint_auth_methods_supported.hasValue())
    {
        input.add_var("token_endpoint_auth_methods_supported", ::OpenAPI::toStringValue(token_endpoint_auth_methods_supported.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (request_scope_readonly.hasValue())
    {
        input.add_var("request_scope_READONLY", ::OpenAPI::toStringValue(request_scope_readonly.value()));
    }
    if (request_scope_namespaces.hasValue())
    {
        input.add_var("request_scope_NAMESPACES", ::OpenAPI::toStringValue(request_scope_namespaces.value()));
    }
    if (request_scope_jobs.hasValue())
    {
        input.add_var("request_scope_JOBS", ::OpenAPI::toStringValue(request_scope_jobs.value()));
    }
    if (request_scope_users.hasValue())
    {
        input.add_var("request_scope_USERS", ::OpenAPI::toStringValue(request_scope_users.value()));
    }
    if (request_scope_hypercube.hasValue())
    {
        input.add_var("request_scope_HYPERCUBE", ::OpenAPI::toStringValue(request_scope_hypercube.value()));
    }
    if (request_scope_cleanup.hasValue())
    {
        input.add_var("request_scope_CLEANUP", ::OpenAPI::toStringValue(request_scope_cleanup.value()));
    }
    if (request_scope_licenses.hasValue())
    {
        input.add_var("request_scope_LICENSES", ::OpenAPI::toStringValue(request_scope_licenses.value()));
    }
    if (request_scope_usage.hasValue())
    {
        input.add_var("request_scope_USAGE", ::OpenAPI::toStringValue(request_scope_usage.value()));
    }
    if (request_scope_auth.hasValue())
    {
        input.add_var("request_scope_AUTH", ::OpenAPI::toStringValue(request_scope_auth.value()));
    }
    if (request_scope_configuration.hasValue())
    {
        input.add_var("request_scope_CONFIGURATION", ::OpenAPI::toStringValue(request_scope_configuration.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createOAuth2IdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createOAuth2IdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createOAuth2IdentityProviderSignal(output);
        Q_EMIT createOAuth2IdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createOAuth2IdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT createOAuth2IdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createOAuth2IdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT createOAuth2IdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::createOIDCIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const QList<QString> &scopes, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &device_client_secret, const ::OpenAPI::OptionalParam<QList<QString>> &extra_client_ids, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QList<QString>> &token_endpoint_auth_methods_supported) {
    QString fullPath = QString(_serverConfigs["createOIDCIdentityProvider"][_serverIndices.value("createOIDCIdentityProvider")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    if (device_client_secret.hasValue())
    {
        input.add_var("device_client_secret", ::OpenAPI::toStringValue(device_client_secret.value()));
    }
    if (extra_client_ids.hasValue())
    {
        input.add_var("extra_client_ids", ::OpenAPI::toStringValue(extra_client_ids.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (token_endpoint_auth_methods_supported.hasValue())
    {
        input.add_var("token_endpoint_auth_methods_supported", ::OpenAPI::toStringValue(token_endpoint_auth_methods_supported.value()));
    }
    
    {
        input.add_var("scopes", ::OpenAPI::toStringValue(scopes));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::createOIDCIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::createOIDCIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createOIDCIdentityProviderSignal(output);
        Q_EMIT createOIDCIdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createOIDCIdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT createOIDCIdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createOIDCIdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT createOIDCIdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::deleteIdentityProvider(const QString &name) {
    QString fullPath = QString(_serverConfigs["deleteIdentityProvider"][_serverIndices.value("deleteIdentityProvider")].URL()+"/auth/providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::deleteIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::deleteIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteIdentityProviderSignal(output);
        Q_EMIT deleteIdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteIdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT deleteIdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteIdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT deleteIdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::fetchOAuth2TokenOnBehalf(const QString &identity_provider_name, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &code, const ::OpenAPI::OptionalParam<QString> &code_verifier, const ::OpenAPI::OptionalParam<QString> &redirect_uri, const ::OpenAPI::OptionalParam<QString> &device_code) {
    QString fullPath = QString(_serverConfigs["fetchOAuth2TokenOnBehalf"][_serverIndices.value("fetchOAuth2TokenOnBehalf")].URL()+"/auth/oauth2-token");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (grant_type.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "grant_type", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("grant_type")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(grant_type.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("identity_provider_name", ::OpenAPI::toStringValue(identity_provider_name));
    }
    if (code.hasValue())
    {
        input.add_var("code", ::OpenAPI::toStringValue(code.value()));
    }
    if (code_verifier.hasValue())
    {
        input.add_var("code_verifier", ::OpenAPI::toStringValue(code_verifier.value()));
    }
    if (redirect_uri.hasValue())
    {
        input.add_var("redirect_uri", ::OpenAPI::toStringValue(redirect_uri.value()));
    }
    if (device_code.hasValue())
    {
        input.add_var("device_code", ::OpenAPI::toStringValue(device_code.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::fetchOAuth2TokenOnBehalfCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::fetchOAuth2TokenOnBehalfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIForwarded_token_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT fetchOAuth2TokenOnBehalfSignal(output);
        Q_EMIT fetchOAuth2TokenOnBehalfSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT fetchOAuth2TokenOnBehalfSignalE(output, error_type, error_str);
        Q_EMIT fetchOAuth2TokenOnBehalfSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT fetchOAuth2TokenOnBehalfSignalError(output, error_type, error_str);
        Q_EMIT fetchOAuth2TokenOnBehalfSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::getPasswordPolicy() {
    QString fullPath = QString(_serverConfigs["getPasswordPolicy"][_serverIndices.value("getPasswordPolicy")].URL()+"/auth/password-policy");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::getPasswordPolicyCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::getPasswordPolicyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPassword_policy output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPasswordPolicySignal(output);
        Q_EMIT getPasswordPolicySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPasswordPolicySignalE(output, error_type, error_str);
        Q_EMIT getPasswordPolicySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPasswordPolicySignalError(output, error_type, error_str);
        Q_EMIT getPasswordPolicySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::invalidateJWTTokens() {
    QString fullPath = QString(_serverConfigs["invalidateJWTTokens"][_serverIndices.value("invalidateJWTTokens")].URL()+"/auth/logout");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::invalidateJWTTokensCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::invalidateJWTTokensCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT invalidateJWTTokensSignal(output);
        Q_EMIT invalidateJWTTokensSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT invalidateJWTTokensSignalE(output, error_type, error_str);
        Q_EMIT invalidateJWTTokensSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT invalidateJWTTokensSignalError(output, error_type, error_str);
        Q_EMIT invalidateJWTTokensSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listAllIdentityProviders() {
    QString fullPath = QString(_serverConfigs["listAllIdentityProviders"][_serverIndices.value("listAllIdentityProviders")].URL()+"/auth/providers/all");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listAllIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listAllIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIdentity_provider val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listAllIdentityProvidersSignal(output);
        Q_EMIT listAllIdentityProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listAllIdentityProvidersSignalE(output, error_type, error_str);
        Q_EMIT listAllIdentityProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listAllIdentityProvidersSignalError(output, error_type, error_str);
        Q_EMIT listAllIdentityProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name) {
    QString fullPath = QString(_serverConfigs["listIdentityProviders"][_serverIndices.value("listIdentityProviders")].URL()+"/auth/providers");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIdentity_provider val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listIdentityProvidersSignal(output);
        Q_EMIT listIdentityProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listIdentityProvidersSignalE(output, error_type, error_str);
        Q_EMIT listIdentityProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listIdentityProvidersSignalError(output, error_type, error_str);
        Q_EMIT listIdentityProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listLDAPIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listLDAPIdentityProviders"][_serverIndices.value("listLDAPIdentityProviders")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listLDAPIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listLDAPIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentity_provider_ldap output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listLDAPIdentityProvidersSignal(output);
        Q_EMIT listLDAPIdentityProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listLDAPIdentityProvidersSignalE(output, error_type, error_str);
        Q_EMIT listLDAPIdentityProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listLDAPIdentityProvidersSignalError(output, error_type, error_str);
        Q_EMIT listLDAPIdentityProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listOAuth2IdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listOAuth2IdentityProviders"][_serverIndices.value("listOAuth2IdentityProviders")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listOAuth2IdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listOAuth2IdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider_oauth2_with_secret> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIdentity_provider_oauth2_with_secret val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listOAuth2IdentityProvidersSignal(output);
        Q_EMIT listOAuth2IdentityProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listOAuth2IdentityProvidersSignalE(output, error_type, error_str);
        Q_EMIT listOAuth2IdentityProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listOAuth2IdentityProvidersSignalError(output, error_type, error_str);
        Q_EMIT listOAuth2IdentityProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::listOIDCIdentityProviders(const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["listOIDCIdentityProviders"][_serverIndices.value("listOIDCIdentityProviders")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::listOIDCIdentityProvidersCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::listOIDCIdentityProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentity_provider_oidc_with_secret> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIdentity_provider_oidc_with_secret val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listOIDCIdentityProvidersSignal(output);
        Q_EMIT listOIDCIdentityProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listOIDCIdentityProvidersSignalE(output, error_type, error_str);
        Q_EMIT listOIDCIdentityProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listOIDCIdentityProvidersSignalError(output, error_type, error_str);
        Q_EMIT listOIDCIdentityProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::loginWithLDAP(const QString &provider_name, const QString &username, const QString &password, const ::OpenAPI::OptionalParam<QString> &grant_type, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in, const ::OpenAPI::OptionalParam<QList<QString>> &access_scopes) {
    QString fullPath = QString(_serverConfigs["loginWithLDAP"][_serverIndices.value("loginWithLDAP")].URL()+"/auth/ldap-providers/{provider_name}/login");
    
    
    {
        QString provider_namePathParam("{");
        provider_namePathParam.append("provider_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider_name"+pathSuffix : pathPrefix;
        fullPath.replace(provider_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (grant_type.hasValue())
    {
        input.add_var("grant_type", ::OpenAPI::toStringValue(grant_type.value()));
    }
    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }
    
    {
        input.add_var("password", ::OpenAPI::toStringValue(password));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }
    if (access_scopes.hasValue())
    {
        input.add_var("access_scopes", ::OpenAPI::toStringValue(access_scopes.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::loginWithLDAPCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::loginWithLDAPCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT loginWithLDAPSignal(output);
        Q_EMIT loginWithLDAPSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT loginWithLDAPSignalE(output, error_type, error_str);
        Q_EMIT loginWithLDAPSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT loginWithLDAPSignalError(output, error_type, error_str);
        Q_EMIT loginWithLDAPSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::loginWithOIDC(const QString &id_token, const ::OpenAPI::OptionalParam<QString> &scope, const ::OpenAPI::OptionalParam<qint32> &expires_in) {
    QString fullPath = QString(_serverConfigs["loginWithOIDC"][_serverIndices.value("loginWithOIDC")].URL()+"/auth/oidc-providers/login");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("id_token", ::OpenAPI::toStringValue(id_token));
    }
    if (scope.hasValue())
    {
        input.add_var("scope", ::OpenAPI::toStringValue(scope.value()));
    }
    if (expires_in.hasValue())
    {
        input.add_var("expires_in", ::OpenAPI::toStringValue(expires_in.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::loginWithOIDCCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::loginWithOIDCCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIModel_auth_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT loginWithOIDCSignal(output);
        Q_EMIT loginWithOIDCSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT loginWithOIDCSignalE(output, error_type, error_str);
        Q_EMIT loginWithOIDCSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT loginWithOIDCSignalError(output, error_type, error_str);
        Q_EMIT loginWithOIDCSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateLDAPIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &host, const qint32 &port, const QString &uid, const QString &encryption, const QString &base, const QString &user_filter, const ::OpenAPI::OptionalParam<QString> &bind_dn, const ::OpenAPI::OptionalParam<QString> &password, const ::OpenAPI::OptionalParam<bool> &verify_certificates, const ::OpenAPI::OptionalParam<bool> &active_directory) {
    QString fullPath = QString(_serverConfigs["updateLDAPIdentityProvider"][_serverIndices.value("updateLDAPIdentityProvider")].URL()+"/auth/ldap-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("host", ::OpenAPI::toStringValue(host));
    }
    
    {
        input.add_var("port", ::OpenAPI::toStringValue(port));
    }
    
    {
        input.add_var("uid", ::OpenAPI::toStringValue(uid));
    }
    if (bind_dn.hasValue())
    {
        input.add_var("bind_dn", ::OpenAPI::toStringValue(bind_dn.value()));
    }
    if (password.hasValue())
    {
        input.add_var("password", ::OpenAPI::toStringValue(password.value()));
    }
    
    {
        input.add_var("encryption", ::OpenAPI::toStringValue(encryption));
    }
    if (verify_certificates.hasValue())
    {
        input.add_var("verify_certificates", ::OpenAPI::toStringValue(verify_certificates.value()));
    }
    if (active_directory.hasValue())
    {
        input.add_var("active_directory", ::OpenAPI::toStringValue(active_directory.value()));
    }
    
    {
        input.add_var("base", ::OpenAPI::toStringValue(base));
    }
    
    {
        input.add_var("user_filter", ::OpenAPI::toStringValue(user_filter));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateLDAPIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateLDAPIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateLDAPIdentityProviderSignal(output);
        Q_EMIT updateLDAPIdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateLDAPIdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT updateLDAPIdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateLDAPIdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT updateLDAPIdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateOAuth2IdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &override_audience, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<bool> &use_oauth2_auth_server_metadata, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QList<QString>> &response_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &grant_types_supported, const ::OpenAPI::OptionalParam<QList<QString>> &token_endpoint_auth_methods_supported, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &request_scope_readonly, const ::OpenAPI::OptionalParam<QString> &request_scope_namespaces, const ::OpenAPI::OptionalParam<QString> &request_scope_jobs, const ::OpenAPI::OptionalParam<QString> &request_scope_users, const ::OpenAPI::OptionalParam<QString> &request_scope_hypercube, const ::OpenAPI::OptionalParam<QString> &request_scope_cleanup, const ::OpenAPI::OptionalParam<QString> &request_scope_licenses, const ::OpenAPI::OptionalParam<QString> &request_scope_usage, const ::OpenAPI::OptionalParam<QString> &request_scope_auth, const ::OpenAPI::OptionalParam<QString> &request_scope_configuration) {
    QString fullPath = QString(_serverConfigs["updateOAuth2IdentityProvider"][_serverIndices.value("updateOAuth2IdentityProvider")].URL()+"/auth/oauth2-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (override_audience.hasValue())
    {
        input.add_var("override_audience", ::OpenAPI::toStringValue(override_audience.value()));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (use_oauth2_auth_server_metadata.hasValue())
    {
        input.add_var("use_oauth2_auth_server_metadata", ::OpenAPI::toStringValue(use_oauth2_auth_server_metadata.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (response_types_supported.hasValue())
    {
        input.add_var("response_types_supported", ::OpenAPI::toStringValue(response_types_supported.value()));
    }
    if (grant_types_supported.hasValue())
    {
        input.add_var("grant_types_supported", ::OpenAPI::toStringValue(grant_types_supported.value()));
    }
    if (token_endpoint_auth_methods_supported.hasValue())
    {
        input.add_var("token_endpoint_auth_methods_supported", ::OpenAPI::toStringValue(token_endpoint_auth_methods_supported.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (request_scope_readonly.hasValue())
    {
        input.add_var("request_scope_READONLY", ::OpenAPI::toStringValue(request_scope_readonly.value()));
    }
    if (request_scope_namespaces.hasValue())
    {
        input.add_var("request_scope_NAMESPACES", ::OpenAPI::toStringValue(request_scope_namespaces.value()));
    }
    if (request_scope_jobs.hasValue())
    {
        input.add_var("request_scope_JOBS", ::OpenAPI::toStringValue(request_scope_jobs.value()));
    }
    if (request_scope_users.hasValue())
    {
        input.add_var("request_scope_USERS", ::OpenAPI::toStringValue(request_scope_users.value()));
    }
    if (request_scope_hypercube.hasValue())
    {
        input.add_var("request_scope_HYPERCUBE", ::OpenAPI::toStringValue(request_scope_hypercube.value()));
    }
    if (request_scope_cleanup.hasValue())
    {
        input.add_var("request_scope_CLEANUP", ::OpenAPI::toStringValue(request_scope_cleanup.value()));
    }
    if (request_scope_licenses.hasValue())
    {
        input.add_var("request_scope_LICENSES", ::OpenAPI::toStringValue(request_scope_licenses.value()));
    }
    if (request_scope_usage.hasValue())
    {
        input.add_var("request_scope_USAGE", ::OpenAPI::toStringValue(request_scope_usage.value()));
    }
    if (request_scope_auth.hasValue())
    {
        input.add_var("request_scope_AUTH", ::OpenAPI::toStringValue(request_scope_auth.value()));
    }
    if (request_scope_configuration.hasValue())
    {
        input.add_var("request_scope_CONFIGURATION", ::OpenAPI::toStringValue(request_scope_configuration.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateOAuth2IdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateOAuth2IdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateOAuth2IdentityProviderSignal(output);
        Q_EMIT updateOAuth2IdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateOAuth2IdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT updateOAuth2IdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateOAuth2IdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT updateOAuth2IdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updateOIDCIdentityProvider(const QString &name, const QString &label, const bool &hidden, const QString &web_ui_client_id, const QString &issuer, const QList<QString> &scopes, const ::OpenAPI::OptionalParam<QString> &web_ui_client_secret, const ::OpenAPI::OptionalParam<QString> &device_client_id, const ::OpenAPI::OptionalParam<QString> &device_client_secret, const ::OpenAPI::OptionalParam<QList<QString>> &extra_client_ids, const ::OpenAPI::OptionalParam<bool> &use_oidc_discover, const ::OpenAPI::OptionalParam<QString> &authorization_endpoint, const ::OpenAPI::OptionalParam<QString> &token_endpoint, const ::OpenAPI::OptionalParam<QString> &jwks_uri, const ::OpenAPI::OptionalParam<QString> &end_session_endpoint, const ::OpenAPI::OptionalParam<QString> &device_authorization_endpoint, const ::OpenAPI::OptionalParam<QList<QString>> &token_endpoint_auth_methods_supported) {
    QString fullPath = QString(_serverConfigs["updateOIDCIdentityProvider"][_serverIndices.value("updateOIDCIdentityProvider")].URL()+"/auth/oidc-providers");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("name", ::OpenAPI::toStringValue(name));
    }
    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }
    
    {
        input.add_var("hidden", ::OpenAPI::toStringValue(hidden));
    }
    
    {
        input.add_var("web_ui_client_id", ::OpenAPI::toStringValue(web_ui_client_id));
    }
    if (web_ui_client_secret.hasValue())
    {
        input.add_var("web_ui_client_secret", ::OpenAPI::toStringValue(web_ui_client_secret.value()));
    }
    if (device_client_id.hasValue())
    {
        input.add_var("device_client_id", ::OpenAPI::toStringValue(device_client_id.value()));
    }
    if (device_client_secret.hasValue())
    {
        input.add_var("device_client_secret", ::OpenAPI::toStringValue(device_client_secret.value()));
    }
    if (extra_client_ids.hasValue())
    {
        input.add_var("extra_client_ids", ::OpenAPI::toStringValue(extra_client_ids.value()));
    }
    
    {
        input.add_var("issuer", ::OpenAPI::toStringValue(issuer));
    }
    if (use_oidc_discover.hasValue())
    {
        input.add_var("use_oidc_discover", ::OpenAPI::toStringValue(use_oidc_discover.value()));
    }
    if (authorization_endpoint.hasValue())
    {
        input.add_var("authorization_endpoint", ::OpenAPI::toStringValue(authorization_endpoint.value()));
    }
    if (token_endpoint.hasValue())
    {
        input.add_var("token_endpoint", ::OpenAPI::toStringValue(token_endpoint.value()));
    }
    if (jwks_uri.hasValue())
    {
        input.add_var("jwks_uri", ::OpenAPI::toStringValue(jwks_uri.value()));
    }
    if (end_session_endpoint.hasValue())
    {
        input.add_var("end_session_endpoint", ::OpenAPI::toStringValue(end_session_endpoint.value()));
    }
    if (device_authorization_endpoint.hasValue())
    {
        input.add_var("device_authorization_endpoint", ::OpenAPI::toStringValue(device_authorization_endpoint.value()));
    }
    if (token_endpoint_auth_methods_supported.hasValue())
    {
        input.add_var("token_endpoint_auth_methods_supported", ::OpenAPI::toStringValue(token_endpoint_auth_methods_supported.value()));
    }
    
    {
        input.add_var("scopes", ::OpenAPI::toStringValue(scopes));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updateOIDCIdentityProviderCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updateOIDCIdentityProviderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateOIDCIdentityProviderSignal(output);
        Q_EMIT updateOIDCIdentityProviderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateOIDCIdentityProviderSignalE(output, error_type, error_str);
        Q_EMIT updateOIDCIdentityProviderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateOIDCIdentityProviderSignalError(output, error_type, error_str);
        Q_EMIT updateOIDCIdentityProviderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::updatePasswordPolicy(const qint32 &min_password_length, const bool &must_include_uppercase, const bool &must_include_lowercase, const bool &must_include_number, const bool &must_include_special_char, const bool &not_in_popular_passwords) {
    QString fullPath = QString(_serverConfigs["updatePasswordPolicy"][_serverIndices.value("updatePasswordPolicy")].URL()+"/auth/password-policy");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("min_password_length", ::OpenAPI::toStringValue(min_password_length));
    }
    
    {
        input.add_var("must_include_uppercase", ::OpenAPI::toStringValue(must_include_uppercase));
    }
    
    {
        input.add_var("must_include_lowercase", ::OpenAPI::toStringValue(must_include_lowercase));
    }
    
    {
        input.add_var("must_include_number", ::OpenAPI::toStringValue(must_include_number));
    }
    
    {
        input.add_var("must_include_special_char", ::OpenAPI::toStringValue(must_include_special_char));
    }
    
    {
        input.add_var("not_in_popular_passwords", ::OpenAPI::toStringValue(not_in_popular_passwords));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAuthApi::updatePasswordPolicyCallback);
    connect(this, &OAIAuthApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAuthApi::updatePasswordPolicyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePasswordPolicySignal(output);
        Q_EMIT updatePasswordPolicySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePasswordPolicySignalE(output, error_type, error_str);
        Q_EMIT updatePasswordPolicySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePasswordPolicySignalError(output, error_type, error_str);
        Q_EMIT updatePasswordPolicySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAuthApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
