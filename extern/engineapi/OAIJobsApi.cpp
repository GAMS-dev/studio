/**
 * GAMS Engine
 * With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.
 *
 * The version of the OpenAPI document: 25.04.23
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIJobsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIJobsApi::OAIJobsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIJobsApi::~OAIJobsApi() {
}

void OAIJobsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//localhost/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("consumeStreamEntry", defaultConf);
    _serverIndices.insert("consumeStreamEntry", 0);
    _serverConfigs.insert("createJob", defaultConf);
    _serverIndices.insert("createJob", 0);
    _serverConfigs.insert("deleteJobZip", defaultConf);
    _serverIndices.insert("deleteJobZip", 0);
    _serverConfigs.insert("getJob", defaultConf);
    _serverIndices.insert("getJob", 0);
    _serverConfigs.insert("getJobTextEntry", defaultConf);
    _serverIndices.insert("getJobTextEntry", 0);
    _serverConfigs.insert("getJobTextEntryInfo", defaultConf);
    _serverIndices.insert("getJobTextEntryInfo", 0);
    _serverConfigs.insert("getJobZip", defaultConf);
    _serverIndices.insert("getJobZip", 0);
    _serverConfigs.insert("getJobZipInfo", defaultConf);
    _serverIndices.insert("getJobZipInfo", 0);
    _serverConfigs.insert("getStatusCodes", defaultConf);
    _serverIndices.insert("getStatusCodes", 0);
    _serverConfigs.insert("killJob", defaultConf);
    _serverIndices.insert("killJob", 0);
    _serverConfigs.insert("listJobs", defaultConf);
    _serverIndices.insert("listJobs", 0);
    _serverConfigs.insert("popJobLogs", defaultConf);
    _serverIndices.insert("popJobLogs", 0);
    _serverConfigs.insert("popStreamEntry", defaultConf);
    _serverIndices.insert("popStreamEntry", 0);
    _serverConfigs.insert("queryJobTextEntry", defaultConf);
    _serverIndices.insert("queryJobTextEntry", 0);
    _serverConfigs.insert("queryJobTextEntryInfo", defaultConf);
    _serverIndices.insert("queryJobTextEntryInfo", 0);
    _serverConfigs.insert("updateJobAccessGroups", defaultConf);
    _serverIndices.insert("updateJobAccessGroups", 0);
    _serverConfigs.insert("updateJobTag", defaultConf);
    _serverIndices.insert("updateJobTag", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIJobsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIJobsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIJobsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIJobsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIJobsApi::setUsername(const QString &username) {
    _username = username;
}

void OAIJobsApi::setPassword(const QString &password) {
    _password = password;
}


void OAIJobsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIJobsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIJobsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIJobsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIJobsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIJobsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIJobsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIJobsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIJobsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIJobsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIJobsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIJobsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIJobsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIJobsApi::consumeStreamEntry(const QString &token, const QString &entry_name) {
    QString fullPath = QString(_serverConfigs["consumeStreamEntry"][_serverIndices.value("consumeStreamEntry")].URL()+"/jobs/{token}/stream-entry");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "entry_name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("entry_name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::consumeStreamEntryCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::consumeStreamEntryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStream_entry output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT consumeStreamEntrySignal(output);
        Q_EMIT consumeStreamEntrySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT consumeStreamEntrySignalE(output, error_type, error_str);
        Q_EMIT consumeStreamEntrySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT consumeStreamEntrySignalError(output, error_type, error_str);
        Q_EMIT consumeStreamEntrySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::createJob(const QString &model, const QString &r_namespace, const ::OpenAPI::OptionalParam<QString> &run, const ::OpenAPI::OptionalParam<QString> &inex_string, const ::OpenAPI::OptionalParam<QList<QString>> &text_entries, const ::OpenAPI::OptionalParam<QList<QString>> &stream_entries, const ::OpenAPI::OptionalParam<QString> &stdout_filename, const ::OpenAPI::OptionalParam<QList<QString>> &arguments, const ::OpenAPI::OptionalParam<QList<QString>> &dep_tokens, const ::OpenAPI::OptionalParam<QList<QString>> &labels, const ::OpenAPI::OptionalParam<QString> &tag, const ::OpenAPI::OptionalParam<QList<QString>> &access_groups, const ::OpenAPI::OptionalParam<QString> &priority, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &model_data, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &data, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file) {
    QString fullPath = QString(_serverConfigs["createJob"][_serverIndices.value("createJob")].URL()+"/jobs/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "model", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("model")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    if (run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(run.stringValue())));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "namespace", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("namespace")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    if (inex_string.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "inex_string", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("inex_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(inex_string.stringValue())));
    }
    if (text_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "text_entries", true);
        if (text_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : text_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("text_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : text_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : text_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stream_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stream_entries", true);
        if (stream_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : stream_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("stream_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                for (QString t : stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stdout_filename.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stdout_filename", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("stdout_filename")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(stdout_filename.stringValue())));
    }
    if (arguments.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "arguments", true);
        if (arguments.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : arguments.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("arguments=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                for (QString t : arguments.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                for (QString t : arguments.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                for (QString t : arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                for (QString t : arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                for (QString t : arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (dep_tokens.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dep_tokens", true);
        if (dep_tokens.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : dep_tokens.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("dep_tokens=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("dep_tokens").append(querySuffix);
                qint32 count = 0;
                for (QString t : dep_tokens.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("dep_tokens").append(querySuffix);
                qint32 count = 0;
                for (QString t : dep_tokens.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("dep_tokens").append(querySuffix);
                qint32 count = 0;
                for (QString t : dep_tokens.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("dep_tokens").append(querySuffix);
                qint32 count = 0;
                for (QString t : dep_tokens.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("dep_tokens").append(querySuffix);
                qint32 count = 0;
                for (QString t : dep_tokens.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (labels.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "labels", true);
        if (labels.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : labels.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("labels=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("labels").append(querySuffix);
                qint32 count = 0;
                for (QString t : labels.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("labels").append(querySuffix);
                qint32 count = 0;
                for (QString t : labels.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("labels").append(querySuffix);
                qint32 count = 0;
                for (QString t : labels.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("labels").append(querySuffix);
                qint32 count = 0;
                for (QString t : labels.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("labels").append(querySuffix);
                qint32 count = 0;
                for (QString t : labels.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (tag.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("tag")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag.stringValue())));
    }
    if (access_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "access_groups", true);
        if (access_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : access_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("access_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (priority.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "priority", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("priority")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(priority.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (model_data.hasValue())
    {
        input.add_file("model_data", model_data.value().local_filename, model_data.value().request_filename, model_data.value().mime_type);
    }
    if (data.hasValue())
    {
        input.add_file("data", data.value().local_filename, data.value().request_filename, data.value().mime_type);
    }
    if (inex_file.hasValue())
    {
        input.add_file("inex_file", inex_file.value().local_filename, inex_file.value().request_filename, inex_file.value().mime_type);
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::createJobCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::createJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage_and_token output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createJobSignal(output);
        Q_EMIT createJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createJobSignalE(output, error_type, error_str);
        Q_EMIT createJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createJobSignalError(output, error_type, error_str);
        Q_EMIT createJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::deleteJobZip(const QString &token) {
    QString fullPath = QString(_serverConfigs["deleteJobZip"][_serverIndices.value("deleteJobZip")].URL()+"/jobs/{token}/result");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::deleteJobZipCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::deleteJobZipCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteJobZipSignal(output);
        Q_EMIT deleteJobZipSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteJobZipSignalE(output, error_type, error_str);
        Q_EMIT deleteJobZipSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteJobZipSignalError(output, error_type, error_str);
        Q_EMIT deleteJobZipSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getJob(const QString &token, const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["getJob"][_serverIndices.value("getJob")].URL()+"/jobs/{token}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getJobCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIJob output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getJobSignal(output);
        Q_EMIT getJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getJobSignalE(output, error_type, error_str);
        Q_EMIT getJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getJobSignalError(output, error_type, error_str);
        Q_EMIT getJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getJobTextEntry(const QString &token, const QString &entry_name, const ::OpenAPI::OptionalParam<qint32> &start_position, const ::OpenAPI::OptionalParam<qint32> &length) {
    QString fullPath = QString(_serverConfigs["getJobTextEntry"][_serverIndices.value("getJobTextEntry")].URL()+"/jobs/{token}/text-entry/{entry_name}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    
    {
        QString entry_namePathParam("{");
        entry_namePathParam.append("entry_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entry_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entry_name"+pathSuffix : pathPrefix;
        fullPath.replace(entry_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (start_position.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "start_position", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("start_position")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(start_position.stringValue())));
    }
    if (length.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "length", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("length")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(length.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getJobTextEntryCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getJobTextEntryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIText_entry output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getJobTextEntrySignal(output);
        Q_EMIT getJobTextEntrySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getJobTextEntrySignalE(output, error_type, error_str);
        Q_EMIT getJobTextEntrySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getJobTextEntrySignalError(output, error_type, error_str);
        Q_EMIT getJobTextEntrySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getJobTextEntryInfo(const QString &token, const QString &entry_name) {
    QString fullPath = QString(_serverConfigs["getJobTextEntryInfo"][_serverIndices.value("getJobTextEntryInfo")].URL()+"/jobs/{token}/text-entry/{entry_name}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    
    {
        QString entry_namePathParam("{");
        entry_namePathParam.append("entry_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entry_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entry_name"+pathSuffix : pathPrefix;
        fullPath.replace(entry_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "HEAD");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getJobTextEntryInfoCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getJobTextEntryInfoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getJobTextEntryInfoSignal();
        Q_EMIT getJobTextEntryInfoSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getJobTextEntryInfoSignalE(error_type, error_str);
        Q_EMIT getJobTextEntryInfoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getJobTextEntryInfoSignalError(error_type, error_str);
        Q_EMIT getJobTextEntryInfoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getJobZip(const QString &token) {
    QString fullPath = QString(_serverConfigs["getJobZip"][_serverIndices.value("getJobZip")].URL()+"/jobs/{token}/result");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getJobZipCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getJobZipCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getJobZipSignal(output);
        Q_EMIT getJobZipSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getJobZipSignalE(output, error_type, error_str);
        Q_EMIT getJobZipSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getJobZipSignalError(output, error_type, error_str);
        Q_EMIT getJobZipSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getJobZipInfo(const QString &token) {
    QString fullPath = QString(_serverConfigs["getJobZipInfo"][_serverIndices.value("getJobZipInfo")].URL()+"/jobs/{token}/result");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "HEAD");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getJobZipInfoCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getJobZipInfoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getJobZipInfoSignal();
        Q_EMIT getJobZipInfoSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getJobZipInfoSignalE(error_type, error_str);
        Q_EMIT getJobZipInfoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getJobZipInfoSignalError(error_type, error_str);
        Q_EMIT getJobZipInfoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::getStatusCodes(const ::OpenAPI::OptionalParam<QString> &x_fields) {
    QString fullPath = QString(_serverConfigs["getStatusCodes"][_serverIndices.value("getStatusCodes")].URL()+"/jobs/status-codes");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::getStatusCodesCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::getStatusCodesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIStatus_code_meaning> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIStatus_code_meaning val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStatusCodesSignal(output);
        Q_EMIT getStatusCodesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStatusCodesSignalE(output, error_type, error_str);
        Q_EMIT getStatusCodesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStatusCodesSignalError(output, error_type, error_str);
        Q_EMIT getStatusCodesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::killJob(const QString &token, const ::OpenAPI::OptionalParam<bool> &hard_kill) {
    QString fullPath = QString(_serverConfigs["killJob"][_serverIndices.value("killJob")].URL()+"/jobs/{token}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (hard_kill.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "hard_kill", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("hard_kill")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(hard_kill.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::killJobCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::killJobCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT killJobSignal(output);
        Q_EMIT killJobSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT killJobSignalE(output, error_type, error_str);
        Q_EMIT killJobSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT killJobSignalError(output, error_type, error_str);
        Q_EMIT killJobSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::listJobs(const ::OpenAPI::OptionalParam<bool> &everyone, const ::OpenAPI::OptionalParam<QString> &x_fields, const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<QString> &order_by, const ::OpenAPI::OptionalParam<bool> &order_asc, const ::OpenAPI::OptionalParam<bool> &show_only_active) {
    QString fullPath = QString(_serverConfigs["listJobs"][_serverIndices.value("listJobs")].URL()+"/jobs/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (everyone.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "everyone", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("everyone")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(everyone.stringValue())));
    }
    if (page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(page.stringValue())));
    }
    if (per_page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(per_page.stringValue())));
    }
    if (order_by.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "order_by", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("order_by")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(order_by.stringValue())));
    }
    if (order_asc.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "order_asc", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("order_asc")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(order_asc.stringValue())));
    }
    if (show_only_active.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "show_only_active", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("show_only_active")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(show_only_active.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::listJobsCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::listJobsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIJob_no_text_entry_page output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listJobsSignal(output);
        Q_EMIT listJobsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listJobsSignalE(output, error_type, error_str);
        Q_EMIT listJobsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listJobsSignalError(output, error_type, error_str);
        Q_EMIT listJobsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::popJobLogs(const QString &token) {
    QString fullPath = QString(_serverConfigs["popJobLogs"][_serverIndices.value("popJobLogs")].URL()+"/jobs/{token}/unread-logs");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::popJobLogsCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::popJobLogsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILog_piece output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT popJobLogsSignal(output);
        Q_EMIT popJobLogsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT popJobLogsSignalE(output, error_type, error_str);
        Q_EMIT popJobLogsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT popJobLogsSignalError(output, error_type, error_str);
        Q_EMIT popJobLogsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::popStreamEntry(const QString &token, const QString &entry_name) {
    QString fullPath = QString(_serverConfigs["popStreamEntry"][_serverIndices.value("popStreamEntry")].URL()+"/jobs/{token}/stream-entry/{entry_name}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    
    {
        QString entry_namePathParam("{");
        entry_namePathParam.append("entry_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entry_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entry_name"+pathSuffix : pathPrefix;
        fullPath.replace(entry_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::popStreamEntryCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::popStreamEntryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStream_entry output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT popStreamEntrySignal(output);
        Q_EMIT popStreamEntrySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT popStreamEntrySignalE(output, error_type, error_str);
        Q_EMIT popStreamEntrySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT popStreamEntrySignalError(output, error_type, error_str);
        Q_EMIT popStreamEntrySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::queryJobTextEntry(const QString &token, const QString &entry_name, const ::OpenAPI::OptionalParam<qint32> &start_position, const ::OpenAPI::OptionalParam<qint32> &length) {
    QString fullPath = QString(_serverConfigs["queryJobTextEntry"][_serverIndices.value("queryJobTextEntry")].URL()+"/jobs/{token}/text-entry");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "entry_name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("entry_name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    if (start_position.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "start_position", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("start_position")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(start_position.stringValue())));
    }
    if (length.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "length", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("length")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(length.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::queryJobTextEntryCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::queryJobTextEntryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIText_entry output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryJobTextEntrySignal(output);
        Q_EMIT queryJobTextEntrySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryJobTextEntrySignalE(output, error_type, error_str);
        Q_EMIT queryJobTextEntrySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryJobTextEntrySignalError(output, error_type, error_str);
        Q_EMIT queryJobTextEntrySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::queryJobTextEntryInfo(const QString &token, const QString &entry_name) {
    QString fullPath = QString(_serverConfigs["queryJobTextEntryInfo"][_serverIndices.value("queryJobTextEntryInfo")].URL()+"/jobs/{token}/text-entry");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "entry_name", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("entry_name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(entry_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "HEAD");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::queryJobTextEntryInfoCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::queryJobTextEntryInfoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryJobTextEntryInfoSignal();
        Q_EMIT queryJobTextEntryInfoSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryJobTextEntryInfoSignalE(error_type, error_str);
        Q_EMIT queryJobTextEntryInfoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryJobTextEntryInfoSignalError(error_type, error_str);
        Q_EMIT queryJobTextEntryInfoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::updateJobAccessGroups(const QString &token, const ::OpenAPI::OptionalParam<QList<QString>> &access_groups) {
    QString fullPath = QString(_serverConfigs["updateJobAccessGroups"][_serverIndices.value("updateJobAccessGroups")].URL()+"/jobs/{token}/access-groups");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (access_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "access_groups", true);
        if (access_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : access_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("access_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("access_groups").append(querySuffix);
                qint32 count = 0;
                for (QString t : access_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::updateJobAccessGroupsCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::updateJobAccessGroupsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateJobAccessGroupsSignal(output);
        Q_EMIT updateJobAccessGroupsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateJobAccessGroupsSignalE(output, error_type, error_str);
        Q_EMIT updateJobAccessGroupsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateJobAccessGroupsSignalError(output, error_type, error_str);
        Q_EMIT updateJobAccessGroupsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::updateJobTag(const QString &token, const QString &tag) {
    QString fullPath = QString(_serverConfigs["updateJobTag"][_serverIndices.value("updateJobTag")].URL()+"/jobs/{token}/tag");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("tag")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJobsApi::updateJobTagCallback);
    connect(this, &OAIJobsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJobsApi::updateJobTagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateJobTagSignal(output);
        Q_EMIT updateJobTagSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateJobTagSignalE(output, error_type, error_str);
        Q_EMIT updateJobTagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateJobTagSignalError(output, error_type, error_str);
        Q_EMIT updateJobTagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJobsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
