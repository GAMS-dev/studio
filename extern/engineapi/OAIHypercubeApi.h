/**
 * GAMS Engine
 * With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.
 *
 * The version of the OpenAPI document: latest
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIHypercubeApi_H
#define OAI_OAIHypercubeApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIHttpFileElement.h"
#include "OAIHypercube_page.h"
#include "OAIHypercube_token.h"
#include "OAIMessage.h"
#include "OAIQuota_exceeded.h"
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIHypercubeApi : public QObject {
    Q_OBJECT

public:
    OAIHypercubeApi(const int timeOut = 0);
    ~OAIHypercubeApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  model QString [required]
    * @param[in]  r_namespace QString [required]
    * @param[in]  hypercube_file OAIHttpFileElement [required]
    * @param[in]  run QString [optional]
    * @param[in]  inex_string QString [optional]
    * @param[in]  arguments QList<QString> [optional]
    * @param[in]  dep_tokens QList<QString> [optional]
    * @param[in]  labels QList<QString> [optional]
    * @param[in]  tag QString [optional]
    * @param[in]  access_groups QList<QString> [optional]
    * @param[in]  stdout_filename QString [optional]
    * @param[in]  model_data OAIHttpFileElement [optional]
    * @param[in]  data OAIHttpFileElement [optional]
    * @param[in]  inex_file OAIHttpFileElement [optional]
    */
    void createHypercube(const QString &model, const QString &r_namespace, const OAIHttpFileElement &hypercube_file, const ::OpenAPI::OptionalParam<QString> &run = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &inex_string = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QList<QString>> &arguments = ::OpenAPI::OptionalParam<QList<QString>>(), const ::OpenAPI::OptionalParam<QList<QString>> &dep_tokens = ::OpenAPI::OptionalParam<QList<QString>>(), const ::OpenAPI::OptionalParam<QList<QString>> &labels = ::OpenAPI::OptionalParam<QList<QString>>(), const ::OpenAPI::OptionalParam<QString> &tag = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QList<QString>> &access_groups = ::OpenAPI::OptionalParam<QList<QString>>(), const ::OpenAPI::OptionalParam<QString> &stdout_filename = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<OAIHttpFileElement> &model_data = ::OpenAPI::OptionalParam<OAIHttpFileElement>(), const ::OpenAPI::OptionalParam<OAIHttpFileElement> &data = ::OpenAPI::OptionalParam<OAIHttpFileElement>(), const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file = ::OpenAPI::OptionalParam<OAIHttpFileElement>());

    /**
    * @param[in]  hypercube_token QString [required]
    */
    void deleteHypercubeZip(const QString &hypercube_token);

    /**
    * @param[in]  hypercube_token QString [required]
    */
    void getHypercubeZip(const QString &hypercube_token);

    /**
    * @param[in]  hypercube_token QString [required]
    */
    void getHypercubeZipInfo(const QString &hypercube_token);

    /**
    * @param[in]  hypercube_token QString [required]
    * @param[in]  hard_kill bool [optional]
    */
    void killHypercube(const QString &hypercube_token, const ::OpenAPI::OptionalParam<bool> &hard_kill = ::OpenAPI::OptionalParam<bool>());

    /**
    * @param[in]  hypercube_token QString [optional]
    * @param[in]  everyone bool [optional]
    * @param[in]  page qint32 [optional]
    * @param[in]  per_page qint32 [optional]
    * @param[in]  x_fields QString [optional]
    * @param[in]  order_by QString [optional]
    * @param[in]  order_asc bool [optional]
    * @param[in]  show_only_active bool [optional]
    */
    void listHypercubes(const ::OpenAPI::OptionalParam<QString> &hypercube_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<bool> &everyone = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<qint32> &page = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &per_page = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<QString> &x_fields = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &order_by = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<bool> &order_asc = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<bool> &show_only_active = ::OpenAPI::OptionalParam<bool>());

    /**
    * @param[in]  hypercube_token QString [required]
    * @param[in]  access_groups QList<QString> [optional]
    */
    void updateHypercubeAccessGroups(const QString &hypercube_token, const ::OpenAPI::OptionalParam<QList<QString>> &access_groups = ::OpenAPI::OptionalParam<QList<QString>>());

    /**
    * @param[in]  hypercube_token QString [required]
    * @param[in]  tag QString [required]
    */
    void updateHypercubeTag(const QString &hypercube_token, const QString &tag);


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void createHypercubeCallback(OAIHttpRequestWorker *worker);
    void deleteHypercubeZipCallback(OAIHttpRequestWorker *worker);
    void getHypercubeZipCallback(OAIHttpRequestWorker *worker);
    void getHypercubeZipInfoCallback(OAIHttpRequestWorker *worker);
    void killHypercubeCallback(OAIHttpRequestWorker *worker);
    void listHypercubesCallback(OAIHttpRequestWorker *worker);
    void updateHypercubeAccessGroupsCallback(OAIHttpRequestWorker *worker);
    void updateHypercubeTagCallback(OAIHttpRequestWorker *worker);

signals:

    void createHypercubeSignal(OAIHypercube_token summary);
    void deleteHypercubeZipSignal(OAIMessage summary);
    void getHypercubeZipSignal(OAIHttpFileElement summary);
    void getHypercubeZipInfoSignal();
    void killHypercubeSignal(OAIMessage summary);
    void listHypercubesSignal(OAIHypercube_page summary);
    void updateHypercubeAccessGroupsSignal(OAIMessage summary);
    void updateHypercubeTagSignal(OAIMessage summary);

    void createHypercubeSignalFull(OAIHttpRequestWorker *worker, OAIHypercube_token summary);
    void deleteHypercubeZipSignalFull(OAIHttpRequestWorker *worker, OAIMessage summary);
    void getHypercubeZipSignalFull(OAIHttpRequestWorker *worker, OAIHttpFileElement summary);
    void getHypercubeZipInfoSignalFull(OAIHttpRequestWorker *worker);
    void killHypercubeSignalFull(OAIHttpRequestWorker *worker, OAIMessage summary);
    void listHypercubesSignalFull(OAIHttpRequestWorker *worker, OAIHypercube_page summary);
    void updateHypercubeAccessGroupsSignalFull(OAIHttpRequestWorker *worker, OAIMessage summary);
    void updateHypercubeTagSignalFull(OAIHttpRequestWorker *worker, OAIMessage summary);

    void createHypercubeSignalE(OAIHypercube_token summary, QNetworkReply::NetworkError error_type, QString error_str);
    void deleteHypercubeZipSignalE(OAIMessage summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getHypercubeZipSignalE(OAIHttpFileElement summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getHypercubeZipInfoSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void killHypercubeSignalE(OAIMessage summary, QNetworkReply::NetworkError error_type, QString error_str);
    void listHypercubesSignalE(OAIHypercube_page summary, QNetworkReply::NetworkError error_type, QString error_str);
    void updateHypercubeAccessGroupsSignalE(OAIMessage summary, QNetworkReply::NetworkError error_type, QString error_str);
    void updateHypercubeTagSignalE(OAIMessage summary, QNetworkReply::NetworkError error_type, QString error_str);

    void createHypercubeSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void deleteHypercubeZipSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getHypercubeZipSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getHypercubeZipInfoSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void killHypercubeSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void listHypercubesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void updateHypercubeAccessGroupsSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void updateHypercubeTagSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public slots:
    void tokenAvailable();
    
};

} // namespace OpenAPI
#endif
