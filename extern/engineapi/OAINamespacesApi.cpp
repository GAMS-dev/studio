/**
 * GAMS Engine
 * With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.
 *
 * The version of the OpenAPI document: 23.02.18
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINamespacesApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAINamespacesApi::OAINamespacesApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAINamespacesApi::~OAINamespacesApi() {
}

void OAINamespacesApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//localhost/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("addUserToGroup", defaultConf);
    _serverIndices.insert("addUserToGroup", 0);
    _serverConfigs.insert("createModel", defaultConf);
    _serverIndices.insert("createModel", 0);
    _serverConfigs.insert("createModelDeprecated", defaultConf);
    _serverIndices.insert("createModelDeprecated", 0);
    _serverConfigs.insert("createNamespace", defaultConf);
    _serverIndices.insert("createNamespace", 0);
    _serverConfigs.insert("createUserGroup", defaultConf);
    _serverIndices.insert("createUserGroup", 0);
    _serverConfigs.insert("deleteModel", defaultConf);
    _serverIndices.insert("deleteModel", 0);
    _serverConfigs.insert("deleteModelDeprecated", defaultConf);
    _serverIndices.insert("deleteModelDeprecated", 0);
    _serverConfigs.insert("deleteNamespace", defaultConf);
    _serverIndices.insert("deleteNamespace", 0);
    _serverConfigs.insert("deleteNamespaceQuota", defaultConf);
    _serverIndices.insert("deleteNamespaceQuota", 0);
    _serverConfigs.insert("deleteUserGroup", defaultConf);
    _serverIndices.insert("deleteUserGroup", 0);
    _serverConfigs.insert("getAccessibleNamespaces", defaultConf);
    _serverIndices.insert("getAccessibleNamespaces", 0);
    _serverConfigs.insert("getModel", defaultConf);
    _serverIndices.insert("getModel", 0);
    _serverConfigs.insert("getModelDeprecated", defaultConf);
    _serverIndices.insert("getModelDeprecated", 0);
    _serverConfigs.insert("getMyPermissions", defaultConf);
    _serverIndices.insert("getMyPermissions", 0);
    _serverConfigs.insert("getNamespaceQuota", defaultConf);
    _serverIndices.insert("getNamespaceQuota", 0);
    _serverConfigs.insert("getUserGroups", defaultConf);
    _serverIndices.insert("getUserGroups", 0);
    _serverConfigs.insert("getUserPermission", defaultConf);
    _serverIndices.insert("getUserPermission", 0);
    _serverConfigs.insert("listModels", defaultConf);
    _serverIndices.insert("listModels", 0);
    _serverConfigs.insert("listNamespaces", defaultConf);
    _serverIndices.insert("listNamespaces", 0);
    _serverConfigs.insert("removeUserFromGroup", defaultConf);
    _serverIndices.insert("removeUserFromGroup", 0);
    _serverConfigs.insert("replaceUserPermission", defaultConf);
    _serverIndices.insert("replaceUserPermission", 0);
    _serverConfigs.insert("updateModel", defaultConf);
    _serverIndices.insert("updateModel", 0);
    _serverConfigs.insert("updateModelDeprecated", defaultConf);
    _serverIndices.insert("updateModelDeprecated", 0);
    _serverConfigs.insert("updateNamespaceQuota", defaultConf);
    _serverIndices.insert("updateNamespaceQuota", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAINamespacesApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAINamespacesApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAINamespacesApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName,apiKey);
}

void OAINamespacesApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAINamespacesApi::setUsername(const QString &username) {
    _username = username;
}

void OAINamespacesApi::setPassword(const QString &password) {
    _password = password;
}


void OAINamespacesApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAINamespacesApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAINamespacesApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAINamespacesApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAINamespacesApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 12, 0)
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
#else
    for (auto &e : _serverIndices.keys()) {
        setServerIndex(e, addServerConfiguration(e, url, description, variables));
    }
#endif
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAINamespacesApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAINamespacesApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAINamespacesApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAINamespacesApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAINamespacesApi::abortRequests() {
    emit abortRequestsSignal();
}

QString OAINamespacesApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAINamespacesApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAINamespacesApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAINamespacesApi::addUserToGroup(const QString &r_namespace, const QString &label, const QString &username) {
    QString fullPath = QString(_serverConfigs["addUserToGroup"][_serverIndices.value("addUserToGroup")].URL()+"/namespaces/{namespace}/user-groups/{label}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString labelPathParam("{");
        labelPathParam.append("label").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "label", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"label"+pathSuffix : pathPrefix;
        fullPath.replace(labelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(label)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::addUserToGroupCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::addUserToGroupCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit addUserToGroupSignal(output);
        emit addUserToGroupSignalFull(worker, output);
    } else {
        emit addUserToGroupSignalE(output, error_type, error_str);
        emit addUserToGroupSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::createModel(const QString &r_namespace, const QString &model, const OAIHttpFileElement &data, const ::OpenAPI::OptionalParam<QString> &inex_string, const ::OpenAPI::OptionalParam<QList<QString>> &arguments, const ::OpenAPI::OptionalParam<QList<QString>> &text_entries, const ::OpenAPI::OptionalParam<QList<QString>> &stream_entries, const ::OpenAPI::OptionalParam<QString> &run, const ::OpenAPI::OptionalParam<bool> &protect_model_files, const ::OpenAPI::OptionalParam<QList<QString>> &user_groups, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file) {
    QString fullPath = QString(_serverConfigs["createModel"][_serverIndices.value("createModel")].URL()+"/namespaces/{namespace}/models/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (inex_string.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "inex_string", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("inex_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(inex_string.value())));
    }
    if (arguments.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "arguments", true);
        if (arguments.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, arguments.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("arguments=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (text_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "text_entries", true);
        if (text_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, text_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("text_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stream_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stream_entries", true);
        if (stream_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, stream_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("stream_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(run.value())));
    }
    if (protect_model_files.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "protect_model_files", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("protect_model_files")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(protect_model_files.value())));
    }
    if (user_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_groups", true);
        if (user_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, user_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("user_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_file("data", data.local_filename, data.request_filename, data.mime_type);
    }
    if (inex_file.hasValue())
    {
        input.add_file("inex_file", inex_file.value().local_filename, inex_file.value().request_filename, inex_file.value().mime_type);
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::createModelCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::createModelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createModelSignal(output);
        emit createModelSignalFull(worker, output);
    } else {
        emit createModelSignalE(output, error_type, error_str);
        emit createModelSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::createModelDeprecated(const QString &r_namespace, const QString &model, const OAIHttpFileElement &data, const ::OpenAPI::OptionalParam<QString> &inex_string, const ::OpenAPI::OptionalParam<QList<QString>> &arguments, const ::OpenAPI::OptionalParam<QList<QString>> &text_entries, const ::OpenAPI::OptionalParam<QList<QString>> &stream_entries, const ::OpenAPI::OptionalParam<QString> &run, const ::OpenAPI::OptionalParam<bool> &protect_model_files, const ::OpenAPI::OptionalParam<QList<QString>> &user_groups, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file) {
    QString fullPath = QString(_serverConfigs["createModelDeprecated"][_serverIndices.value("createModelDeprecated")].URL()+"/namespaces/{namespace}/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (inex_string.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "inex_string", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("inex_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(inex_string.value())));
    }
    if (arguments.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "arguments", true);
        if (arguments.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, arguments.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("arguments=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (text_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "text_entries", true);
        if (text_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, text_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("text_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stream_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stream_entries", true);
        if (stream_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, stream_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("stream_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(run.value())));
    }
    if (protect_model_files.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "protect_model_files", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("protect_model_files")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(protect_model_files.value())));
    }
    if (user_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_groups", true);
        if (user_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, user_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("user_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_file("data", data.local_filename, data.request_filename, data.mime_type);
    }
    if (inex_file.hasValue())
    {
        input.add_file("inex_file", inex_file.value().local_filename, inex_file.value().request_filename, inex_file.value().mime_type);
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::createModelDeprecatedCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::createModelDeprecatedCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createModelDeprecatedSignal(output);
        emit createModelDeprecatedSignalFull(worker, output);
    } else {
        emit createModelDeprecatedSignalE(output, error_type, error_str);
        emit createModelDeprecatedSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::createNamespace(const QString &r_namespace, const ::OpenAPI::OptionalParam<qint32> &disk_quota) {
    QString fullPath = QString(_serverConfigs["createNamespace"][_serverIndices.value("createNamespace")].URL()+"/namespaces/{namespace}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (disk_quota.hasValue())
    {
        input.add_var("disk_quota", ::OpenAPI::toStringValue(disk_quota.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::createNamespaceCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::createNamespaceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createNamespaceSignal(output);
        emit createNamespaceSignalFull(worker, output);
    } else {
        emit createNamespaceSignalE(output, error_type, error_str);
        emit createNamespaceSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::createUserGroup(const QString &r_namespace, const QString &label) {
    QString fullPath = QString(_serverConfigs["createUserGroup"][_serverIndices.value("createUserGroup")].URL()+"/namespaces/{namespace}/user-groups");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("label", ::OpenAPI::toStringValue(label));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::createUserGroupCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::createUserGroupCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createUserGroupSignal(output);
        emit createUserGroupSignalFull(worker, output);
    } else {
        emit createUserGroupSignalE(output, error_type, error_str);
        emit createUserGroupSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::deleteModel(const QString &r_namespace, const QString &model) {
    QString fullPath = QString(_serverConfigs["deleteModel"][_serverIndices.value("deleteModel")].URL()+"/namespaces/{namespace}/models/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::deleteModelCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::deleteModelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteModelSignal(output);
        emit deleteModelSignalFull(worker, output);
    } else {
        emit deleteModelSignalE(output, error_type, error_str);
        emit deleteModelSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::deleteModelDeprecated(const QString &r_namespace, const QString &model) {
    QString fullPath = QString(_serverConfigs["deleteModelDeprecated"][_serverIndices.value("deleteModelDeprecated")].URL()+"/namespaces/{namespace}/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::deleteModelDeprecatedCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::deleteModelDeprecatedCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteModelDeprecatedSignal(output);
        emit deleteModelDeprecatedSignalFull(worker, output);
    } else {
        emit deleteModelDeprecatedSignalE(output, error_type, error_str);
        emit deleteModelDeprecatedSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::deleteNamespace(const QString &r_namespace) {
    QString fullPath = QString(_serverConfigs["deleteNamespace"][_serverIndices.value("deleteNamespace")].URL()+"/namespaces/{namespace}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::deleteNamespaceCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::deleteNamespaceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteNamespaceSignal(output);
        emit deleteNamespaceSignalFull(worker, output);
    } else {
        emit deleteNamespaceSignalE(output, error_type, error_str);
        emit deleteNamespaceSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::deleteNamespaceQuota(const QString &r_namespace) {
    QString fullPath = QString(_serverConfigs["deleteNamespaceQuota"][_serverIndices.value("deleteNamespaceQuota")].URL()+"/namespaces/{namespace}/disk-quota");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::deleteNamespaceQuotaCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::deleteNamespaceQuotaCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteNamespaceQuotaSignal(output);
        emit deleteNamespaceQuotaSignalFull(worker, output);
    } else {
        emit deleteNamespaceQuotaSignalE(output, error_type, error_str);
        emit deleteNamespaceQuotaSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::deleteUserGroup(const QString &r_namespace, const QString &label) {
    QString fullPath = QString(_serverConfigs["deleteUserGroup"][_serverIndices.value("deleteUserGroup")].URL()+"/namespaces/{namespace}/user-groups");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "label", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("label")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(label)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::deleteUserGroupCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::deleteUserGroupCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteUserGroupSignal(output);
        emit deleteUserGroupSignalFull(worker, output);
    } else {
        emit deleteUserGroupSignalE(output, error_type, error_str);
        emit deleteUserGroupSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getAccessibleNamespaces() {
    QString fullPath = QString(_serverConfigs["getAccessibleNamespaces"][_serverIndices.value("getAccessibleNamespaces")].URL()+"/namespaces/permissions/me");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getAccessibleNamespacesCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getAccessibleNamespacesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINamespace_with_permission> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAINamespace_with_permission val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAccessibleNamespacesSignal(output);
        emit getAccessibleNamespacesSignalFull(worker, output);
    } else {
        emit getAccessibleNamespacesSignalE(output, error_type, error_str);
        emit getAccessibleNamespacesSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getModel(const QString &r_namespace, const QString &model) {
    QString fullPath = QString(_serverConfigs["getModel"][_serverIndices.value("getModel")].URL()+"/namespaces/{namespace}/models/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getModelCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getModelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getModelSignal(output);
        emit getModelSignalFull(worker, output);
    } else {
        emit getModelSignalE(output, error_type, error_str);
        emit getModelSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getModelDeprecated(const QString &r_namespace, const QString &model) {
    QString fullPath = QString(_serverConfigs["getModelDeprecated"][_serverIndices.value("getModelDeprecated")].URL()+"/namespaces/{namespace}/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getModelDeprecatedCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getModelDeprecatedCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getModelDeprecatedSignal(output);
        emit getModelDeprecatedSignalFull(worker, output);
    } else {
        emit getModelDeprecatedSignalE(output, error_type, error_str);
        emit getModelDeprecatedSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getMyPermissions(const QString &r_namespace) {
    QString fullPath = QString(_serverConfigs["getMyPermissions"][_serverIndices.value("getMyPermissions")].URL()+"/namespaces/{namespace}/permissions/me");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getMyPermissionsCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getMyPermissionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPerm_and_username output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMyPermissionsSignal(output);
        emit getMyPermissionsSignalFull(worker, output);
    } else {
        emit getMyPermissionsSignalE(output, error_type, error_str);
        emit getMyPermissionsSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getNamespaceQuota(const QString &r_namespace) {
    QString fullPath = QString(_serverConfigs["getNamespaceQuota"][_serverIndices.value("getNamespaceQuota")].URL()+"/namespaces/{namespace}/disk-quota");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getNamespaceQuotaCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getNamespaceQuotaCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINamespace_quota output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getNamespaceQuotaSignal(output);
        emit getNamespaceQuotaSignalFull(worker, output);
    } else {
        emit getNamespaceQuotaSignalE(output, error_type, error_str);
        emit getNamespaceQuotaSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getUserGroups(const QString &r_namespace) {
    QString fullPath = QString(_serverConfigs["getUserGroups"][_serverIndices.value("getUserGroups")].URL()+"/namespaces/{namespace}/user-groups");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getUserGroupsCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getUserGroupsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIUser_groups> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIUser_groups val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUserGroupsSignal(output);
        emit getUserGroupsSignalFull(worker, output);
    } else {
        emit getUserGroupsSignalE(output, error_type, error_str);
        emit getUserGroupsSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::getUserPermission(const QString &r_namespace, const QString &username) {
    QString fullPath = QString(_serverConfigs["getUserPermission"][_serverIndices.value("getUserPermission")].URL()+"/namespaces/{namespace}/permissions");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "username", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("username")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(username)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::getUserPermissionCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::getUserPermissionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPerm_and_username output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUserPermissionSignal(output);
        emit getUserPermissionSignalFull(worker, output);
    } else {
        emit getUserPermissionSignalE(output, error_type, error_str);
        emit getUserPermissionSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::listModels(const QString &r_namespace, const ::OpenAPI::OptionalParam<QString> &x_fields, const ::OpenAPI::OptionalParam<QString> &model) {
    QString fullPath = QString(_serverConfigs["listModels"][_serverIndices.value("listModels")].URL()+"/namespaces/{namespace}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (model.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "model", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("model")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(model.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_fields.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_fields.value()).isEmpty()) {
            input.headers.insert("X-Fields", ::OpenAPI::toStringValue(x_fields.value()));
        }
        }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::listModelsCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::listModelsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIModels> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAIModels val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listModelsSignal(output);
        emit listModelsSignalFull(worker, output);
    } else {
        emit listModelsSignalE(output, error_type, error_str);
        emit listModelsSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::listNamespaces() {
    QString fullPath = QString(_serverConfigs["listNamespaces"][_serverIndices.value("listNamespaces")].URL()+"/namespaces/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::listNamespacesCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::listNamespacesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINamespace> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAINamespace val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit listNamespacesSignal(output);
        emit listNamespacesSignalFull(worker, output);
    } else {
        emit listNamespacesSignalE(output, error_type, error_str);
        emit listNamespacesSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::removeUserFromGroup(const QString &r_namespace, const QString &label, const QString &username) {
    QString fullPath = QString(_serverConfigs["removeUserFromGroup"][_serverIndices.value("removeUserFromGroup")].URL()+"/namespaces/{namespace}/user-groups/{label}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString labelPathParam("{");
        labelPathParam.append("label").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "label", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"label"+pathSuffix : pathPrefix;
        fullPath.replace(labelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(label)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "username", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("username")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(username)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::removeUserFromGroupCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::removeUserFromGroupCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit removeUserFromGroupSignal(output);
        emit removeUserFromGroupSignalFull(worker, output);
    } else {
        emit removeUserFromGroupSignalE(output, error_type, error_str);
        emit removeUserFromGroupSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::replaceUserPermission(const QString &r_namespace, const QString &username, const qint32 &permissions) {
    QString fullPath = QString(_serverConfigs["replaceUserPermission"][_serverIndices.value("replaceUserPermission")].URL()+"/namespaces/{namespace}/permissions");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("username", ::OpenAPI::toStringValue(username));
    }
    
    {
        input.add_var("permissions", ::OpenAPI::toStringValue(permissions));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::replaceUserPermissionCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::replaceUserPermissionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit replaceUserPermissionSignal(output);
        emit replaceUserPermissionSignalFull(worker, output);
    } else {
        emit replaceUserPermissionSignalE(output, error_type, error_str);
        emit replaceUserPermissionSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::updateModel(const QString &r_namespace, const QString &model, const ::OpenAPI::OptionalParam<QString> &inex_string, const ::OpenAPI::OptionalParam<QList<QString>> &arguments, const ::OpenAPI::OptionalParam<QString> &run, const ::OpenAPI::OptionalParam<bool> &protect_model_files, const ::OpenAPI::OptionalParam<QList<QString>> &user_groups, const ::OpenAPI::OptionalParam<QList<QString>> &text_entries, const ::OpenAPI::OptionalParam<QList<QString>> &stream_entries, const ::OpenAPI::OptionalParam<bool> &delete_inex_file, const ::OpenAPI::OptionalParam<bool> &delete_arguments, const ::OpenAPI::OptionalParam<bool> &delete_run, const ::OpenAPI::OptionalParam<bool> &delete_user_groups, const ::OpenAPI::OptionalParam<bool> &delete_text_entries, const ::OpenAPI::OptionalParam<bool> &delete_stream_entries, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &data, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file) {
    QString fullPath = QString(_serverConfigs["updateModel"][_serverIndices.value("updateModel")].URL()+"/namespaces/{namespace}/models/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (inex_string.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "inex_string", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("inex_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(inex_string.value())));
    }
    if (arguments.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "arguments", true);
        if (arguments.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, arguments.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("arguments=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(run.value())));
    }
    if (protect_model_files.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "protect_model_files", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("protect_model_files")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(protect_model_files.value())));
    }
    if (user_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_groups", true);
        if (user_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, user_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("user_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (text_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "text_entries", true);
        if (text_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, text_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("text_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stream_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stream_entries", true);
        if (stream_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, stream_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("stream_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (delete_inex_file.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_inex_file", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_inex_file")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_inex_file.value())));
    }
    if (delete_arguments.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_arguments", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_arguments")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_arguments.value())));
    }
    if (delete_run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_run.value())));
    }
    if (delete_user_groups.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_user_groups", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_user_groups")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_user_groups.value())));
    }
    if (delete_text_entries.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_text_entries", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_text_entries")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_text_entries.value())));
    }
    if (delete_stream_entries.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_stream_entries", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_stream_entries")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_stream_entries.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    if (data.hasValue())
    {
        input.add_file("data", data.value().local_filename, data.value().request_filename, data.value().mime_type);
    }
    if (inex_file.hasValue())
    {
        input.add_file("inex_file", inex_file.value().local_filename, inex_file.value().request_filename, inex_file.value().mime_type);
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::updateModelCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::updateModelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateModelSignal(output);
        emit updateModelSignalFull(worker, output);
    } else {
        emit updateModelSignalE(output, error_type, error_str);
        emit updateModelSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::updateModelDeprecated(const QString &r_namespace, const QString &model, const ::OpenAPI::OptionalParam<QString> &inex_string, const ::OpenAPI::OptionalParam<QList<QString>> &arguments, const ::OpenAPI::OptionalParam<QString> &run, const ::OpenAPI::OptionalParam<bool> &protect_model_files, const ::OpenAPI::OptionalParam<QList<QString>> &user_groups, const ::OpenAPI::OptionalParam<QList<QString>> &text_entries, const ::OpenAPI::OptionalParam<QList<QString>> &stream_entries, const ::OpenAPI::OptionalParam<bool> &delete_inex_file, const ::OpenAPI::OptionalParam<bool> &delete_arguments, const ::OpenAPI::OptionalParam<bool> &delete_run, const ::OpenAPI::OptionalParam<bool> &delete_user_groups, const ::OpenAPI::OptionalParam<bool> &delete_text_entries, const ::OpenAPI::OptionalParam<bool> &delete_stream_entries, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &data, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &inex_file) {
    QString fullPath = QString(_serverConfigs["updateModelDeprecated"][_serverIndices.value("updateModelDeprecated")].URL()+"/namespaces/{namespace}/{model}");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    
    {
        QString modelPathParam("{");
        modelPathParam.append("model").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "model", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"model"+pathSuffix : pathPrefix;
        fullPath.replace(modelPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(model)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (inex_string.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "inex_string", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("inex_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(inex_string.value())));
    }
    if (arguments.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "arguments", true);
        if (arguments.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, arguments.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("arguments=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("arguments").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, arguments.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(run.value())));
    }
    if (protect_model_files.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "protect_model_files", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("protect_model_files")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(protect_model_files.value())));
    }
    if (user_groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_groups", true);
        if (user_groups.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, user_groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("user_groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("user_groups").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, user_groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (text_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "text_entries", true);
        if (text_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, text_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("text_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("text_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, text_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (stream_entries.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "stream_entries", true);
        if (stream_entries.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (QString t, stream_entries.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("stream_entries=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("stream_entries").append(querySuffix);
                qint32 count = 0;
                foreach (QString t, stream_entries.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (delete_inex_file.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_inex_file", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_inex_file")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_inex_file.value())));
    }
    if (delete_arguments.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_arguments", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_arguments")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_arguments.value())));
    }
    if (delete_run.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_run", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_run")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_run.value())));
    }
    if (delete_user_groups.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_user_groups", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_user_groups")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_user_groups.value())));
    }
    if (delete_text_entries.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_text_entries", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_text_entries")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_text_entries.value())));
    }
    if (delete_stream_entries.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "delete_stream_entries", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("delete_stream_entries")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(delete_stream_entries.value())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    if (data.hasValue())
    {
        input.add_file("data", data.value().local_filename, data.value().request_filename, data.value().mime_type);
    }
    if (inex_file.hasValue())
    {
        input.add_file("inex_file", inex_file.value().local_filename, inex_file.value().request_filename, inex_file.value().mime_type);
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::updateModelDeprecatedCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::updateModelDeprecatedCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateModelDeprecatedSignal(output);
        emit updateModelDeprecatedSignalFull(worker, output);
    } else {
        emit updateModelDeprecatedSignalE(output, error_type, error_str);
        emit updateModelDeprecatedSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::updateNamespaceQuota(const QString &r_namespace, const qint32 &disk_quota) {
    QString fullPath = QString(_serverConfigs["updateNamespaceQuota"][_serverIndices.value("updateNamespaceQuota")].URL()+"/namespaces/{namespace}/disk-quota");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString r_namespacePathParam("{");
        r_namespacePathParam.append("namespace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "namespace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"namespace"+pathSuffix : pathPrefix;
        fullPath.replace(r_namespacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(r_namespace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("disk_quota", ::OpenAPI::toStringValue(disk_quota));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINamespacesApi::updateNamespaceQuotaCallback);
    connect(this, &OAINamespacesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINamespacesApi::updateNamespaceQuotaCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessage output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateNamespaceQuotaSignal(output);
        emit updateNamespaceQuotaSignalFull(worker, output);
    } else {
        emit updateNamespaceQuotaSignalE(output, error_type, error_str);
        emit updateNamespaceQuotaSignalEFull(worker, error_type, error_str);
    }
}

void OAINamespacesApi::tokenAvailable(){
  
    oauthToken token; 
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));    
            qDebug() << "Could not retreive a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
